<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="yejx,zhuyingcoder,蘑菇,叶大帅"><meta name="description" content="java,技术分享,后端开发,支付框架,数据接口"><meta name="author" content="removeif"><title>yejx的博客</title><meta description="java,技术分享,后端开发,支付框架,数据接口"><meta property="og:type" content="website"><meta property="og:title" content="竹影の叶"><meta property="og:url" content="https://removeif.github.io/"><meta property="og:site_name" content="竹影の叶"><meta property="og:description" content="java,技术分享,后端开发,支付框架,数据接口"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="removeif"><meta property="article:tag" content="yejx"><meta property="article:tag" content="zhuyingcoder"><meta property="article:tag" content="蘑菇"><meta property="article:tag" content="叶大帅"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://removeif.github.io/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://removeif.github.io/"},"headline":"竹影の叶","image":["https://removeif.github.io/img/avatar.png"],"author":{"@type":"Person","name":"removeif"},"description":"java,技术分享,后端开发,支付框架,数据接口"}</script><link rel="alternative" href="/atom.xml" title="yejx的博客" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atelier-cave-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="yejx的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zhuyingcoder"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card widget">
            <div class="card-content1 card-image">
                <span id="banner"><div class="card-content ">Banner 加载中，请稍等...</div></span>
            </div>
        </div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-07-23  <span class="level-item"><i class="far fa-clock"> </i>2 分钟  <i class="fas fa-pencil-alt"> </i>0.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/23/javase/%E5%85%83%E6%B3%A8%E8%A7%A3/">javase/元注解</a></h1><div class="content"><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>@Target</strong></p>
<p>@Target ：（自定义）注解的作用目标</p>
<pre><code>@Target(ElementType.TYPE)——接口、类、枚举、注解
@Target(ElementType.FIELD)——字段、枚举的常量
@Target(ElementType.METHOD)——方法
@Target(ElementType.PARAMETER)——方法参数
@Target(ElementType.CONSTRUCTOR) ——构造函数
@Target(ElementType.LOCAL_VARIABLE)——局部变量
@Target(ElementType.ANNOTATION_TYPE)——注解
@Target(ElementType.PACKAGE)——包</code></pre><p><strong>@Retention</strong></p>
<p>@Retention ：（自定义）注解的保留位置</p>
<pre><code>RetentionPolicy.SOURCE:（默认）这种类型的Annotations只在源代码级别保留,编译时就会被忽略,在class字节码文件中不包含
RetentionPolicy.CLASS:这种类型的Annotations编译时被保留,默认的保留策略,在class文件中存在,但JVM将会忽略,运行时无法获得
RetentionPolicy.RUNTIME:这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用</code></pre><p><strong>@Document</strong></p>
<p>@Document：说明该注解将被包含在javadoc中，默认情况下,javadoc是不包括注解的，但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 则它的注释成为公共API的一部分<br>@Inherited</p>
<p>@Inherited：说明子类可以继承父类中的该注解（大概作用）</p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-07-11  <span class="level-item"><i class="far fa-clock"> </i>几秒  <i class="fas fa-pencil-alt"> </i>0.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/11/developUtils/easyExcel/">developUtils/easyExcel</a></h1><div class="content"><h1 id="EasyExcel-excel导入导出"><a href="#EasyExcel-excel导入导出" class="headerlink" title="EasyExcel excel导入导出"></a>EasyExcel <sub>excel导入导出</sub></h1><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://www.yuque.com/easyexcel/doc">官方文档</a></h3><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><strong>1、导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、编写实体类(数据载体)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"姓名"</span>, index = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"学号"</span>, index = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> String stuId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"分数"</span>, index = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-07-06  <span class="level-item"><i class="far fa-clock"> </i>几秒  <i class="fas fa-pencil-alt"> </i>0.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/06/developUtils/git/">developUtils/git</a></h1><div class="content"><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>1、将本地仓库长传到远程仓库</p>
<p>git remote add origin 远程仓库地址</p>
<p>git pull origin master</p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/19/frame/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="thumbnail" src="https://i.loli.net/2020/07/23/kGaSAiLqIw3Ez56.jpg" alt="mybatis"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-10-19  <span class="level-item"><i class="far fa-clock"> </i>4 分钟  <i class="fas fa-pencil-alt"> </i>0.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/19/frame/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">mybatis</a></h1><div class="content"><h1 id="MYBATIS源码分析"><a href="#MYBATIS源码分析" class="headerlink" title="MYBATIS源码分析"></a>MYBATIS源码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.加载主配置文件mybatis-config.xml(把文件转换成输入流)</span><br><span class="line">    Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>)</span><br><span class="line"><span class="number">2</span>.通过SqlSessionFactoryBuilder.builder(InputStream)获取sql</span><br><span class="line">	SqlSessionFactory ssf =	<span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream)</span><br><span class="line">   DefaultSqlSessionFactory 是 SqlSessionFactory的实现者</span><br><span class="line"><span class="number">3</span> 通过SqlSessionFactory 获取SqlSession</span><br><span class="line">	SqlSession ss = ssf.openSession(Boolean autoCommit);</span><br><span class="line"><span class="number">4</span>通过 SqlSession.getMapper(Class IDao<span class="class">.<span class="keyword">class</span>)；获取代理对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">5 代理对象调用<span class="title">IDao</span>的<span class="title">Insert</span>、<span class="title">update</span>、<span class="title">select</span>、<span class="title">delete</span></span></span><br></pre></td></tr></table></figure>

<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder类的方法（还有几个重载方法没有列举)</span><br><span class="line"> <span class="number">1</span>、<span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader)</span></span></span><br><span class="line"><span class="function"> 2、SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> 3、SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function"> 4、SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span></span></span><br><span class="line"><span class="function"> 5、<span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br><span class="line"> 方法<span class="number">1</span>、<span class="number">3</span>内部调用了三参方法</span><br><span class="line"> 方法<span class="number">2</span>、<span class="number">4</span>（内部具体实现）</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> 		<span class="comment">//组合了 XMLConfigBuilder对象来解析配置文件</span></span><br><span class="line">      XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Configuration config = parser.parse();</span></span><br><span class="line"><span class="comment">      再将主配置信息config传入</span></span><br><span class="line"><span class="comment">      public SqlSessionFactory build(Configuration config) &#123;</span></span><br><span class="line"><span class="comment">   		 return new DefaultSqlSessionFactory(config);</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		来获取 SqlSessionFactory 对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLConfigBuilder如何解析配置文件"><a href="#XMLConfigBuilder如何解析配置文件" class="headerlink" title="XMLConfigBuilder如何解析配置文件"></a>XMLConfigBuilder如何解析配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class XMLConfigBuilder extends <span class="title">BaseBuilder</span><span class="params">(抽象类)</span></span></span><br><span class="line"><span class="function">	<span class="comment">//成员变量</span></span></span><br><span class="line"><span class="function">  <span class="keyword">private</span> <span class="keyword">boolean</span> parsed</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> XPathParser parser;</span><br><span class="line">  <span class="keyword">private</span> String environment;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory localReflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>、<span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">(Reader reader, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> XPathParser(reader, <span class="keyword">true</span>, props, <span class="keyword">new</span> XMLMapperEntityResolver()), environment, props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>、<span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> XPathParser(inputStream, <span class="keyword">true</span>, props, <span class="keyword">new</span> XMLMapperEntityResolver()), environment, props);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//构造方法1、2内部都调用了私有的构造方法 3</span></span><br><span class="line">  <span class="number">3</span>、<span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">    <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    <span class="keyword">this</span>.parser = parser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="comment">//此方法被SqlSessionFactoryBuilder的build方法调用，用来构造DefaultSqlSessionFactory对象</span></span><br><span class="line">	<span class="comment">//返回一个Configuration总配置对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//涵盖了所有的配置</span></span><br><span class="line"><span class="comment">//mapper注册</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(Configuration c);</span><br><span class="line"><span class="comment">//类型处理器注册</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line"><span class="comment">//类型别名注册</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br><span class="line">   <span class="comment">//主键生成  </span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;KeyGenerator&gt;(<span class="string">"Key Generators collection"</span>);</span><br><span class="line"><span class="comment">//结果映射（一对多，多对多，一对一，多对一)</span></span><br><span class="line"> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;ResultMap&gt;(<span class="string">"Result Maps collection"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存Configuration类中传入的Configuration配置类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"><span class="comment">//定义一个map集合  key -&gt; dao接口  value -&gt; 接口的代理对象 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperRegistry</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/frame/">frame</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/mybatis/">mybatis</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/19/jvm/jvm/"><img class="thumbnail" src="https://i.loli.net/2020/07/23/huavz4GAjmrVxi6.jpg" alt="jvm入门"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-10-19  <span class="level-item"><i class="far fa-clock"> </i>5 分钟  <i class="fas fa-pencil-alt"> </i>0.7 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/19/jvm/jvm/">jvm入门</a></h1><div class="content"><p>java虚拟机，一种能够运行Java字节码的虚拟机，作为一种编译语言的虚拟机。</p>
<p>jvm有很多 不只是hotspot ,还有JRockit ，j9等</p>
<div class="justified-gallery">
<img src="https://i.loli.net/2020/07/23/LWSeKXEjfq7ahx2.png">
</div>
</br>

<h2 id="jvm的基本结构"><a href="#jvm的基本结构" class="headerlink" title="jvm的基本结构"></a>jvm的基本结构</h2><h4 id="jvm由三个主要的子系统构成"><a href="#jvm由三个主要的子系统构成" class="headerlink" title="jvm由三个主要的子系统构成"></a>jvm由三个主要的子系统构成</h4><ol>
<li>类加载子系统</li>
<li>运行时数据区</li>
<li>执行引擎</li>
</ol>
<h5 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h5><ul>
<li><p>启动类加载器</p>
<p>​    负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</p>
</li>
<li><p>扩展类加载器</p>
<p>​    负责加载JRE扩展目录ext中jar类包</p>
</li>
<li><p>系统类加载器</p>
<pre><code>负责加载ClassPath路径下的类包</code></pre></li>
<li><p>用户自定义加载器</p>
</li>
</ul>
<h5 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h5><p>类的生命周期</p>
<ol>
<li><p>加载</p>
<p>将 .class文件从磁盘读到内存</p>
</li>
<li><p>连接</p>
<p>验证</p>
<p>​    验证字节码的正确性</p>
<p>准备</p>
<p>​    给静态变量赋予默认值</p>
<p>解析</p>
<p>​    类装载器装入类所引用的其他所有类</p>
</li>
<li><p>初始化</p>
<p>​    为类的静态变脸赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配真正的初始值，执行静态代码块</p>
</li>
<li><p>使用</p>
</li>
</ol>
<ol start="5">
<li>卸载</li>
</ol>
<ul>
<li><p>全盘负责委托机制</p>
<p>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入</p>
</li>
<li><p>双亲委派机制</p>
<p>指定委托父类加载器寻找目标类，父类在找不到的情况下  在自己的路径中查找并载入目标类</p>
</li>
<li><p>双亲委派模式的优势</p>
</li>
</ul>
<h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><h4 id="GC算法和收集器"><a href="#GC算法和收集器" class="headerlink" title="GC算法和收集器"></a>GC算法和收集器</h4><p>强、软、弱、虚 引用</p>
<p><strong>如何判断对象可以被回收</strong></p>
<p>堆中几乎放着多有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（不能再被任何途径使用的对象）</p>
<p><strong>引用计数法</strong></p>
<p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加一，当引用失效，计数器就减一。任何时候计数器为零的对象就是不可能在被使用的。</p>
<p>确定，很难解决相互引用的问题</p>
<p><strong>可达行分析算法</strong></p>
<p>这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径当成一个对象到GC Roots 没有任何引用链相连的话，则证明此对象不可用。</p>
<p>GcRoots 根节点：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/jvm/">jvm</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/">java虚拟机</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/19/javase/%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86/"><img class="thumbnail" src="https://i.loli.net/2020/06/27/ls234PxomXvG6Oa.jpg" alt="注解解析程序"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-09-19  <span class="level-item"><i class="far fa-clock"> </i>5 分钟  <i class="fas fa-pencil-alt"> </i>0.8 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/19/javase/%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86/">注解解析程序</a></h1><div class="content"><blockquote>
<p>Annotation Process/Parse Tool, APT, 它是我们利用反射API进行注解处理的一种程序。</p>
<p>注解是通过代码的方式进行程序辅助的，JDK中提供了一些注解，包含元注解</p>
<ul>
<li>@Override</li>
<li>@SuppressWarnings</li>
<li>@Deprecated</li>
<li>@SafeVarargs    JDK7加入</li>
<li>@FunctionalInterface  JDK8加入</li>
<li>@Documented</li>
<li>@Inherited</li>
<li>@Retention(value=RetentionPolicy.XXX)<ul>
<li>Retention.SOURCE</li>
<li>Retention.CLASS</li>
<li>Retention.RUNTIME</li>
</ul>
</li>
<li>@Target(value={ElelmentType.XXX, XXXX,XXXX})<ul>
<li>ElementType.METHOD</li>
<li>ElementType.TYPE</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>注：元注解是用来修饰其它注解的注解</strong></p>
</blockquote>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用元注解修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    <span class="comment">//参数的定义</span></span><br><span class="line">    类型 参数名() [<span class="keyword">default</span> 默认值]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中参数的类型有以下几种：</p>
<ul>
<li><p>基本类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举</p>
</li>
<li><p>Class</p>
</li>
<li><p>注解</p>
</li>
<li><p>以上类型的数组</p>
</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><blockquote>
<p>可以在不改变原有对象源代码的基础上，添加新的功能。</p>
<p>它的机制：</p>
<ul>
<li>代理对象与被代理对象会实现同一个接口</li>
<li>利用JDK中提供的 Proxy和InvocationHandler 接口来实现。</li>
</ul>
</blockquote>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>使用组合模式来实现</p>
</blockquote>
<p>案例：</p>
<p>//先定义一个接口 <strong>Movable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//创建一个实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"汽车在移动...."</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Movable m = <span class="keyword">new</span> Car();</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//要求：在不改变 Car类的实现方法move()的情况下, 如何给这个car的move()添加新的操作?</p>
<h3 id="解决思路1，采用静态代理来做"><a href="#解决思路1，采用静态代理来做" class="headerlink" title="解决思路1，采用静态代理来做"></a>解决思路1，采用静态代理来做</h3><ol>
<li>开发一个<strong>代理类</strong>，这个代理类同样要实现 <strong>Movable</strong> 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoveProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MoveProxy</span><span class="params">(Movable target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"汽车在启动之前的检查操作"</span>);</span><br><span class="line">          </span><br><span class="line">       	<span class="comment">//调用被代理对象的真正业务</span></span><br><span class="line">        target.move();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        System.out.println(<span class="string">"汽车移动完成之后的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//现在，调用者代码变成： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Movable m = <span class="keyword">new</span> MoveProxy(<span class="keyword">new</span> Car());</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在调用者这端，拿到的是 Car的代理对象</p>
<blockquote>
<p>注：<strong>静态代理可以达到我们的目的，但是，它的通用性和扩展不够，当接口中多出1个方法或再多实现一个接口时，不光被代理对象要进行修改，我们的静态代理类也要修改</strong>。</p>
</blockquote>
<h3 id="解决思路2，采用动态代理"><a href="#解决思路2，采用动态代理" class="headerlink" title="解决思路2，采用动态代理"></a>解决思路2，采用动态代理</h3><blockquote>
<p>利用JDK中自带的 <code>Proxy</code>和<code>InvocationHandler</code> 两个类型来完成。</p>
<p>要求：</p>
<p><strong>目标对象一定要有实现的接口，没有实现接口的目标对象，JDK自带的Proxy，没有能力为它生成代理对象。</strong></p>
</blockquote>
<h4 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h4><p>常用方法</p>
<ul>
<li><p>Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler);</p>
<p>其中</p>
<ul>
<li>ClassLoader 表示目标对象的类加载器</li>
<li>Class&lt;?&gt;[]  表示目标对象所实现的接口类型，可以有多个，所以才是数组</li>
<li>InvocationHandler  表示创建出来的代理对象要执行的代码，由程序员填入。</li>
</ul>
</li>
</ul>
<h4 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h4><p>常用方法</p>
<ul>
<li><p>Object invoke(Object proxy, Method m, Object[] args);</p>
<p>其中</p>
<ul>
<li>proxy  代理对象</li>
<li>Method  就是目标方法</li>
<li>args  就是目标方法的参数</li>
</ul>
</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Java/">Java</a><span> </span><a class="article-more button is-small link-muted index-categories" href="/categories/Java/java%E5%9F%BA%E7%A1%80/">java基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/java/">java</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/19/javase/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"><img class="thumbnail" src="https://i.loli.net/2020/06/27/ls234PxomXvG6Oa.jpg" alt="流程控制"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-09-19  <span class="level-item"><i class="far fa-clock"> </i>11 分钟  <i class="fas fa-pencil-alt"> </i>1.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/19/javase/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">流程控制</a></h1><div class="content"><blockquote>
<p>也就是程序代码的结构，主要有三种</p>
</blockquote>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote>
<p>从上至下的代码执行结构，没有分支。</p>
</blockquote>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><blockquote>
<p>程序代码在执行时，根据“判断”来决定进入不同的分支之中，java语言提供两种语法：</p>
</blockquote>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断) &#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">if</span>(条件判断) &#123;</span><br><span class="line">    <span class="comment">//代码块1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//代码块2    </span></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span>(条件判断<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//代码块1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(条件判断<span class="number">2</span>) &#123;</span><br><span class="line">	<span class="comment">//代码块2    </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//代码块3	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><blockquote>
<p>也是一个多分支语句结构，它和if不同在于，switch只支持 <code>等值比较</code> 判断，不像if语句那般灵活。</p>
</blockquote>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量因子) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">//代码块1</span></span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">//代码块2</span></span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">case</span> 值N：</span><br><span class="line">        <span class="comment">//代码块N</span></span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//默认代码块</span></span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>变量因子与case的值只能等值比较。所以，变量因子的类型只能是如下类型：</p>
<p>byte, short, char, int</p>
<p>在JDK5.0后，开始支持 枚举[enum]</p>
<p>在JDK7.0后，开始支持 String</p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(expr1;expr2;expr3) &#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line">注：</span><br><span class="line">expr1 表示循环初始化语句，它只执行<span class="number">1</span>次，可以省略</span><br><span class="line">expr2 表示循环条件判断语句，它随循环执行，如果成立，则执行循环体，不成立，则退出循环，可以省略</span><br><span class="line">expr3 表示循环变量因子变化语句，它随循环执行。，可以省略</span><br><span class="line"></span><br><span class="line">三个表达式的执行顺序：</span><br><span class="line">first:  =&gt;  expr1  [<span class="number">1</span>次]</span><br><span class="line">second: =&gt;  expr2  [N次]</span><br><span class="line">third:  =&gt;  循环体  [N次]</span><br><span class="line">last:   =&gt;  expr3  [N次]</span><br><span class="line">所以，如果三个表达式都省略的话，则变成：</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	<span class="comment">//循环体 -- 死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，我们要循环5 次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里，变量i 就不可访问 了</span></span><br><span class="line"></span><br><span class="line">改写成：</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; <span class="number">10</span>; j+=<span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"j = "</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里，变量j 还是可以访问 的。</span></span><br><span class="line">System.out.println(<span class="string">"此时的j的值是："</span>+j);  <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>注：任何局部变量的可见范围只存在于定义它的那一对大括号之中。出了这一对大括号，变量就消失了。</p>
<p><strong>循环也可以嵌套</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//例： 打印输出一个99法则表</p>
<p>– 题目：</p>
<p>打印输出如下的数字：</p>
<p>1*1 = 1</p>
<p>11*11 = 121</p>
<p>111*111 = 12321</p>
<p>….</p>
<p>111111111*111111111=12345678987654321</p>
<p>– 题目：</p>
<p>打印如下数字：</p>
<p>1*8 + 1 = 9</p>
<p>12*8+2=98</p>
<p>123*8+3=987</p>
<p>1234*8+4=9876</p>
<p>12345*8+5=98765</p>
<p>….</p>
<p>123456789*8+9=987654321</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line">同样，循环<span class="number">5</span>次</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>while 循环和for循环的使用场景</p>
<ol>
<li>如果能确定循环次t数，建议使用 for循环</li>
<li>如果是迭代数组或集合，建议使用 for循环</li>
<li>如果事先并不知道循环次数，建议使用while循环</li>
</ol>
</blockquote>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个循环5次的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>注：do while适合交互式菜单的开发，一般是配合 switch 使用。</p>
<h2 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h2><blockquote>
<p>在循环体中，进行控制的语句，其中</p>
<ol>
<li>break 语句表示打破最接近于自己的那一层循环。</li>
<li>continue 语句表示结束本轮循环，当然，它也只影响最接近于自己的那一层循环。</li>
</ol>
</blockquote>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">与</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在Eclipse中，配置代码注释的模板"><a href="#在Eclipse中，配置代码注释的模板" class="headerlink" title="在Eclipse中，配置代码注释的模板"></a>在Eclipse中，配置代码注释的模板</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><blockquote>
<p>就是指系统自动帮助我们进行类型转换，程序员无需做任何操作，一般来说，小范围类型在需要时，会自动向大范围类型 隐式转换。</p>
</blockquote>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>; <span class="comment">//字符型变量 c</span></span><br><span class="line"><span class="keyword">int</span> i = c;  <span class="comment">//ok, 此时，就发生了隐式类型的转换。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">100</span>; <span class="comment">//此时，就发生了隐式类型的转换。</span></span><br></pre></td></tr></table></figure>



<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote>
<p>当你需要把大范围类型的变量赋值 给小范围 类型时，就需要做强制类型的转换</p>
<p>语法：</p>
<p>(类型)变量或表达式</p>
</blockquote>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = b1 + b2; <span class="comment">//compile error</span></span><br><span class="line"><span class="comment">//使用强制类型转换</span></span><br><span class="line"><span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1 + b2);  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再比如：</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">char</span> c = i; <span class="comment">//compile error</span></span><br><span class="line"><span class="comment">//使用强制类型转换</span></span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)i; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>



<h2 id="格式化输出-打印"><a href="#格式化输出-打印" class="headerlink" title="格式化输出/打印"></a>格式化输出/打印</h2><blockquote>
<p>普通的打印输出，调用的是：<code>System.out.println()或System.out.print() 方法</code></p>
<p>格式化打印输出，调用的是：<code>System.out.printf()</code> 方法</p>
</blockquote>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//打印输出 i*j的结果</span></span><br><span class="line">System.out.println(i+<span class="string">"*"</span>+j+<span class="string">"= "</span>+(i*j));</span><br><span class="line"><span class="comment">//这种打印有如下缺点：</span></span><br><span class="line"><span class="number">1</span>. 拼接时容易出错</span><br><span class="line"><span class="number">2</span>. 考虑优先级</span><br><span class="line"><span class="number">3</span>. 字符串拼接性能较低，因为会产生很多临时对象</span><br><span class="line"></span><br><span class="line">现在，我们使用格式化输出，如下：</span><br><span class="line">System.out.printf(<span class="string">"占位符 * 占位符 = 占位符\n"</span>,i, j, i*j);</span><br><span class="line"><span class="comment">//使用这种方式，上面的三个缺点都可以消除，同时，格式化输出还有如下优点：</span></span><br><span class="line"><span class="number">1</span>. 可以指定占位符的字符宽度</span><br><span class="line"><span class="number">2</span>. 可以设定对齐方式</span><br><span class="line"><span class="number">3</span>. 针对浮点数，还可以指定精度</span><br></pre></td></tr></table></figure>

<h3 id="占位符的语法"><a href="#占位符的语法" class="headerlink" title="占位符的语法"></a>占位符的语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[arguments_index$][flag][width][.precision]conversion</span><br></pre></td></tr></table></figure>

<ol>
<li><p>有关 conversion  的字母</p>
<blockquote>
<p>s   –&gt;  字符及字符串</p>
<p>d   –&gt;  整数</p>
<p>f    –&gt;  浮点数</p>
<p>b   –&gt;  布尔值</p>
<p>t    –&gt;  时间或日期，它还需要配合另一个字母【后面在日期格式化再细说】</p>
<p>%  –&gt;  %本身</p>
<p>…</p>
</blockquote>
</li>
</ol>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//打印输出 i*j的结果</span></span><br><span class="line">System.out.printf(<span class="string">"%d*%d=%d\n"</span>, i, j, i*j);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>有关 width </p>
<blockquote>
<p>指定占位符的宽度，如果目标值超过了宽度，则使用目标值的真实宽度。如果目标值没有达到指定的宽度，则使用空格来填充，并且依赖于对齐方式【flag的值】</p>
</blockquote>
</li>
<li><p>有关flag</p>
<blockquote>
<p>一个标记符号，默认是右对齐的，使用 <code>-</code> 表示左对齐</p>
</blockquote>
</li>
</ol>
<ol start="4">
<li><p>有关 精度</p>
<blockquote>
<p>针对浮点数才有意义。</p>
</blockquote>
</li>
<li><p>有关占位符与变量的对应顺序</p>
<blockquote>
<p>默认情况下，替换变量的个数与占位符个数是一一对应的。</p>
<p>如果，替换变量的个数与占位符的个数不一样时，就可以使用 arguments_index$ 来指定。</p>
</blockquote>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Java/">Java</a><span> </span><a class="article-more button is-small link-muted index-categories" href="/categories/Java/java%E5%9F%BA%E7%A1%80/">java基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/java/">java</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/19/javase/%E7%BB%A7%E6%89%BF%20%E5%92%8C%20%E5%A4%9A%E6%80%81/"><img class="thumbnail" src="https://i.loli.net/2020/06/27/ls234PxomXvG6Oa.jpg" alt="继承和多态"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-09-19  <span class="level-item"><i class="far fa-clock"> </i>14 分钟  <i class="fas fa-pencil-alt"> </i>2.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/19/javase/%E7%BB%A7%E6%89%BF%20%E5%92%8C%20%E5%A4%9A%E6%80%81/">继承和多态</a></h1><div class="content"><h2 id="封装的理念"><a href="#封装的理念" class="headerlink" title="封装的理念"></a>封装的理念</h2><blockquote>
<p>针对同一个类中的属性和方法的封装策略： 属性应该私有化，业务方法应该公开化。</p>
<p>针对类中的业务方法的封装策略：</p>
<ul>
<li>把属性、构造、getter/setter方法和业务方法封装在一起。这个优点是类的内聚性高，类的使用简单。缺点是扩展性差、伸缩性差，所以，适合功能单一的类型。</li>
<li>把属性、构造、getter/setter方法单独封装成一个<code>实体类</code>，这个类的对象就成为数据的载体，而把针对此类型的操作单独封装成业务类型，这个业务类型的对象就是功能/方法的载体。 这个优点就是扩展性好，缺点就是学习难度较大，对象之间的关系和调用比较复杂。适合大型的应用设计。</li>
</ul>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>就是指从超类那里继承可以继承的成员。</p>
<p>除了超类中 private 修饰的成员外，其它的成员都被子类所继承，也就是子类可以直接使用。</p>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends</span><br><span class="line">语法：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类型1 <span class="keyword">extends</span> 类型2 </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><ul>
<li>单继承</li>
<li>具有传递性</li>
<li>所有的对象类型都直接或间接地继承于 <strong>java.lang.Object</strong></li>
</ul>
<p>注：<strong>一个类如果没有显示地继承另一个类，则这个类就自动继承 java.lang.Object 类</strong></p>
<h3 id="为什么要用继承"><a href="#为什么要用继承" class="headerlink" title="为什么要用继承"></a>为什么要用继承</h3><blockquote>
<p>最原始的原因当然是为了 代码复用, 但是，通过继承来达到代码复用是要付出很大代价的。</p>
<p>在现在的开发中，如果仅仅是为了代码复用，建议采用 组合/聚合模式，而不是继承。</p>
</blockquote>
<h3 id="何时使用继承？"><a href="#何时使用继承？" class="headerlink" title="何时使用继承？"></a>何时使用继承？</h3><blockquote>
<p>当类之间的关系，满足<code>IS A</code>的关系。 这种情况下，应该使用继承。</p>
<p>如：</p>
<p>我们有一个 水果类 Fruits,  还有一个苹果类 Apple,  很显然， Apple IS A Fruits  是满足的。</p>
</blockquote>
<p>所以，代码可以这么设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水果类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruits</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 苹果类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruits</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有了继承后，父子类中的属性该如何设计？"><a href="#有了继承后，父子类中的属性该如何设计？" class="headerlink" title="有了继承后，父子类中的属性该如何设计？"></a>有了继承后，父子类中的属性该如何设计？</h3><blockquote>
<p>共性设计在<code>父类</code>中</p>
<p>个性设计在<code>子类</code>中</p>
</blockquote>
<h3 id="子类的构造器"><a href="#子类的构造器" class="headerlink" title="子类的构造器"></a>子类的构造器</h3><blockquote>
<p>在子类的构造器中，默认总是会调用父类的空参构造器，当然，我们可以选择父类构造器的调用。</p>
</blockquote>
<h3 id="有了父子类后，创建子类对象的过程"><a href="#有了父子类后，创建子类对象的过程" class="headerlink" title="有了父子类后，创建子类对象的过程"></a>有了父子类后，创建子类对象的过程</h3><p>总是递归地按如下3步先创建父对象</p>
<ol>
<li>申请堆空间</li>
<li>给属性赋默认值</li>
<li>调用构造方法</li>
</ol>
<p>如果在子类的构造器没有指定调用父类的哪个构造器，则总是会调用父类的空参构造，所以，如果父类没有提供空参构造，则子类的构造器会报编译错误。</p>
<p>注：同this调用构造器一样，super() 也必须放在构造器中的第一行位置。</p>
<h3 id="编译时类型和运行时类型"><a href="#编译时类型和运行时类型" class="headerlink" title="编译时类型和运行时类型"></a>编译时类型和运行时类型</h3><blockquote>
<p>编译时类型是指变量在编译期间的类型，可以是 对象类型本身，也可以是父类类型。所以，Object 类可以做为任意对象的编译时类型。【一切皆对象】</p>
<p>运行时类型，是指这个对象的真正类型，它在创建的那一刻就确定了，不会再改变。</p>
</blockquote>
<h2 id="方法的重写-override"><a href="#方法的重写-override" class="headerlink" title="方法的重写[override]"></a>方法的重写[override]</h2><blockquote>
<p>只能在父子类之间存在。</p>
<p>方法重写的要求：</p>
<ol>
<li>方法名必须一样</li>
<li>方法参数必须一样</li>
<li>方法的修饰符，子类的访问控制修饰符必需不能小于父类的访问控修饰符的范围</li>
<li>方法的返回类型，子类的返回类型要么与父类一样，要么是父类返回类型的子类。</li>
<li>方法的异常列表，子类所申明抛出的异常类型要么与父类一样，要么是父类申明抛出异常类型的子类。</li>
</ol>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<p>同一种类型【编译时类型】的对象，调用相同的方法，真正执行的行为不一样，这就是多态。</p>
</blockquote>
<p>在java在，要体现多态性，需要满足如下条件：</p>
<ol>
<li>要有继承</li>
<li>要有方法的重写</li>
</ol>
<p>如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">girth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> radius;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">girth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * Math.PI * <span class="keyword">this</span>.radius; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.PI * Math.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> width;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">girth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(length + width); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length * width; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//表现多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shape c = <span class="keyword">new</span> Circle(<span class="number">4.5</span>);</span><br><span class="line">Shape r = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">System.out.printf(<span class="string">"周长：%.2f, 面积：%.2f\n"</span>, c.girth(), c.area());</span><br><span class="line">System.out.printf(<span class="string">"周长：%.2f, 面积：%.2f\n"</span>, r.girth(), r.area());</span><br><span class="line"></span><br><span class="line"><span class="comment">//改造上面的代码：</span></span><br><span class="line"><span class="comment">//理论准则：对象的编译时类型尽可能地写 父类</span></span><br><span class="line">Shape[] arr = <span class="keyword">new</span> Shape[]&#123;c, r&#125;;</span><br><span class="line"><span class="keyword">for</span>(Shape s : arr) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"周长：%.2f, 面积：%.2f\n"</span>, s.girth(), s.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向父类编程"><a href="#面向父类编程" class="headerlink" title="面向父类编程"></a>面向父类编程</h3><ol>
<li>对象的编译时类型尽可能地写父类</li>
<li>方法的参数尽可能地写父类</li>
<li>方法的返回类型尽可能地写父类</li>
</ol>
<p>编译时类型尽量写父类，好处就是可以以统一的<strong>标准</strong>来处理所有的子类对象。</p>
<p><strong>那么，编译时类型是不是“越大越好”？</strong></p>
<p>当然不是，因为编译时类型决定了这个对象<strong>“所能看到见的行为”</strong>,  所以，<strong>编译时类型要恰到好处</strong></p>
<blockquote>
<p>编译时类型决定 了对象所能看到见的行为。 编译时类型是可变的。</p>
<p>运行时类型决定了对象在执行时的真正行为。 运行时类型是不可变的，它是在<strong>“出生”</strong>时就确定的</p>
</blockquote>
<h2 id="static-和-final-关键字"><a href="#static-和-final-关键字" class="headerlink" title="static 和 final 关键字"></a>static 和 final 关键字</h2><ol>
<li><p>static 修饰方法</p>
<blockquote>
<p>表示方法是静态方法，只能直接访问静态属性，不能直接访问非静态属性。</p>
<p>静态方法的调用是通过 <code>类名.方法名</code> 来调用的。</p>
</blockquote>
</li>
<li><p>static 修饰属性</p>
<blockquote>
<p>表示此属性是静态属性，也叫类变量，它是此类的所有对象/实例 共享的。</p>
<p>静态属性可以被静态方法直接访问。【同一个类中】</p>
<p>同样受访问控制修饰符的影响。</p>
</blockquote>
</li>
<li><p>static 修饰代码块</p>
<blockquote>
<p>表示静态代码块，它是在类加载时发生调用，而且只调用一次。【不是在创建对象时调用】</p>
</blockquote>
</li>
</ol>
<p><strong>有关 final关键字，同样可以修饰如下的成员：</strong></p>
<ol>
<li><p>final修饰类</p>
<blockquote>
<p>表示此类是一个最终类，不能被继承</p>
</blockquote>
</li>
<li><p>final修饰方法</p>
<blockquote>
<p>表示此方法是一个最终方法，不能被子类重写[override]</p>
</blockquote>
</li>
<li><p>final修饰属性</p>
<blockquote>
<p>表示此属性是一个常量属性，常量属性要求在构造方法中初始化或<strong>直接初始化</strong>。</p>
</blockquote>
</li>
<li><p>final修饰局部变量</p>
<blockquote>
<p>表示常量</p>
</blockquote>
</li>
</ol>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p> 封装如下类型</p>
<ol>
<li><p>员工类[Employee]，拥有姓名、手机号、基本工资 3个属性，并提供获取月薪的方法[getMonthSalary]</p>
</li>
<li><p>设计一个小时工类，他的基本工资为0， 拥有 每月工作小时数，每小时费用  2个属性，并重写 父类的 getMonthSalary方法</p>
</li>
<li><p>设计一个销售员工类，拥有 提成率和月销售额 2个属性，并重写父类的 getMonthSalary方法</p>
</li>
<li><p>设计一个固定工资的员工，无其它属性</p>
<p>为了达到面向父类编程的目的，请开发出 EmployeeUtil工具类，提供创建员工的静态方法以及根据员工来获取当月工资的方法。</p>
<p>再开发一个调用者类[UseEmployee]，以数组的方式存放创建好的员工【要求每种员工对象都要有一个】，并打印输出当月的工资。</p>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Java/">Java</a><span> </span><a class="article-more button is-small link-muted index-categories" href="/categories/Java/java%E5%9F%BA%E7%A1%80/">java基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/java/">java</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/19/javase/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><img class="thumbnail" src="https://i.loli.net/2020/06/27/ls234PxomXvG6Oa.jpg" alt="集合框架 JCF"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-09-19  <span class="level-item"><i class="far fa-clock"> </i>9 分钟  <i class="fas fa-pencil-alt"> </i>1.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/19/javase/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合框架 JCF</a></h1><div class="content"><blockquote>
<p>Java Collection Framework, 它是由一组API组成，主要是针对容器的封装，底层有不同的实现，比如：有基于数组的实现，也有链表、哈希算法、二叉树的实现。</p>
<p>在JAVA中，数据的容器有两种</p>
<ol>
<li>基于值的存储， 有：List, Set</li>
<li>基于键、值对的存储, 有 Map</li>
</ol>
</blockquote>
<h2 id="基于值的存储"><a href="#基于值的存储" class="headerlink" title="基于值的存储"></a>基于值的存储</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection</span><br><span class="line">			\- List  有序、可排序、可重复</span><br><span class="line">				\- ArrayList    基于数组的实现</span><br><span class="line">				\- LinkedList	基于链表的实现</span><br><span class="line">				\- Vector       同ArrayList, 它是多线程安全的，它的所有方法都是同步方法</span><br><span class="line">			\- set   无序、不可排序，不可重复</span><br><span class="line">				\- HashSet      使用哈希算法实现的</span><br><span class="line">				\- SortedSet	是Set的一子接口，它是可排序的，当然，也不能重复</span><br><span class="line">					\- TreeSet  使用二叉树实现的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:由于在JAVA中，数组容器在操作上有诸多不便，所以，API提供了JCF供我们使用。如此多的类型，它们各自的特点是不同的。</p>
</blockquote>
<p>针对 List 来说，它的特点是元素有序、可排序，而且可重复，提供了基于数组和双向链表的两种不同的实现，我们在选择时，可以根据实际的情况进行选择。</p>
<h3 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h3><ul>
<li>Iterator iterator() ;    返回当前集合的迭代器</li>
</ul>
<h3 id="Collection的操作方法"><a href="#Collection的操作方法" class="headerlink" title="Collection的操作方法"></a>Collection的操作方法</h3><ul>
<li>boolean add(T  element)     往容器中添加一个新元素</li>
<li>boolean addAll(Collection allElement)  往容器中添加指定容器中的所有元素</li>
<li>boolean remove(T element)  从容器中移除指定的对象</li>
<li>boolean removeAll(Collection elements)  从当前集合中删除指定集合中的所有元素</li>
<li>void clear()   清空容器</li>
<li>boolean contains(T element)   判断当前容器是否包含指定的元素</li>
<li>boolean containsAll(Collection elements) </li>
<li>int size();  获取当前集合有效元素的个数</li>
<li>toArray();  把集合转换成数组</li>
<li>Iterator iterator();   返回指向当前集合的迭代器</li>
</ul>
<h3 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h3><ul>
<li>boolean hasNext()  判断迭代器中是否有下一个可使用的元素</li>
<li>T next()    取出迭代器指向的元素，并把指针向下移动一次。</li>
</ul>
<hr>
<h3 id="List-【有序、不可重复】"><a href="#List-【有序、不可重复】" class="headerlink" title="List 【有序、不可重复】"></a>List 【有序、不可重复】</h3><ul>
<li>T get(int index)    根据下标来访问元素</li>
<li>void set(int index, T element)   把元素Element放到指定的位置</li>
<li>List subList(int start, int end)    求子集，含start位置，不含end位置,  返回的是新的集合</li>
<li>boolean isEmpty() ;  </li>
</ul>
<h3 id="List的实现类"><a href="#List的实现类" class="headerlink" title="List的实现类"></a>List的实现类</h3><ul>
<li>ArrayList<ul>
<li>public ArrayList()</li>
<li>public ArrayList(int size);   </li>
<li>public ArrayList(Collection c)</li>
</ul>
</li>
<li>LinkedList<ul>
<li>public LinkedList();</li>
<li>public LinkedList(Collection c)</li>
</ul>
</li>
</ul>
<h4 id="栈的特点-Stack"><a href="#栈的特点-Stack" class="headerlink" title="栈的特点  Stack"></a>栈的特点  Stack</h4><blockquote>
<p>先进后出，FILO[First In, Last Out], 一般只提供针对栈顶的操作，包含：进栈，出栈，判断栈是否为空，以及栈中的元素个数</p>
</blockquote>
<h4 id="队列的特点-Queue"><a href="#队列的特点-Queue" class="headerlink" title="队列的特点  Queue"></a>队列的特点  Queue</h4><blockquote>
<p>先进先出， First In, First Out[ FIFO ], 一般提从队头的操作【增、删、查】, 包含入队、出列操作</p>
<p>在JCF的API中，有提供这个接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.Queue  [接口]</span><br><span class="line">  			\- java.util.Deque  【接口】</span><br></pre></td></tr></table></figure>

<p>它的方法主要有如下6个，集中在3个功能上，如下 ：</p>
<p><strong>添加操作</strong></p>
<ul>
<li>add(E element)   如果队列容量不够，抛出异常</li>
<li>offer(E element)   如果队列容量不够，则执行失败返回false</li>
</ul>
<p><strong>删除操作</strong></p>
<ul>
<li>remove()  如果队列为空，则抛出异常</li>
<li>poll()  如果队列为空，则返回null</li>
</ul>
<p><strong>查询操作</strong></p>
<ul>
<li>element()   如果队列为空，则抛出异常</li>
<li>peek()      如果队列为空，则返回null</li>
</ul>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p>double end Queue, 简称 Deque， 它支持两端进行操作。它是 Queue的子接口。</p>
</blockquote>
<p>同样，由于它是双端的操作，所以，它的核心方法比 Queue多一倍，也是集中在3个功能。</p>
<p>添加操作、删除操作、查询操作</p>
<h3 id="Collection集合的结构类图"><a href="#Collection集合的结构类图" class="headerlink" title="Collection集合的结构类图"></a>Collection集合的结构类图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Iterable</span><br><span class="line">		\- java.util.Collection</span><br><span class="line">				\- java.util.List</span><br><span class="line">						\- ArrayList</span><br><span class="line">						\- Vector</span><br><span class="line">						\- LinkedList</span><br><span class="line">				\- java.util.Set</span><br><span class="line">						\- HashSet</span><br><span class="line">						\- java.util.SortedSet</span><br><span class="line">								\- TreeSet</span><br><span class="line">				\- java.util.Queue</span><br><span class="line">						\- PriorityQueue</span><br><span class="line">						\- java.util.Deque</span><br><span class="line">								\- ArrayDeque</span><br><span class="line"><span class="comment">//注： 以上带包的都是 接口，不带包的都是 实现类</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-操作"><a href="#Set-操作" class="headerlink" title="Set 操作"></a>Set 操作</h3><blockquote>
<p>几乎与Collection一样。</p>
<p>它的特点是：无序、不可重复</p>
</blockquote>
<p><strong>实现类：HashSet</strong></p>
<blockquote>
<p>它是如何做到 无序以及不可重复的呢？</p>
</blockquote>
<p>首先，当我们把一个对象添加到 HashSet时，这个容器会调用对象的 hashcode()方法，得到一个整数。根据这个整数来计算出此对象应该存放的位置。</p>
<p>其次，当我们再次添加一个对象时，同样会调用此对象的hashcode()方法，得到一个整数，算出它该存储的位置，此时，如果这个位置已经被占用了，则会调用它的 equals()方法，如果返回true, 说明此对象与之前的对象相等，则放弃存入。 如果返回false, 则表示对象不相等，则利用红黑树来存储进行纵向扩展。</p>
<p>注：</p>
<p>上面我们所讲的原理，其实是HashMap的原则，而HashSet中，只是组合了 HashMap，并且只是利用了它的 Key， 而Value永远是同 一个 Object.</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li>把上节课布置的模排诗改成竖排诗的作业利用集合重新来实现一下。</li>
<li>利用循环，随机生成10W个1-100之间的整数，请利用集合来统计出每个整数出现的次数</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Java/">Java</a><span> </span><a class="article-more button is-small link-muted index-categories" href="/categories/Java/java%E5%9F%BA%E7%A1%80/">java基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/javaSE/">javaSE</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/19/javase/IO%E6%B5%81/"><img class="thumbnail" src="https://i.loli.net/2020/06/27/ls234PxomXvG6Oa.jpg" alt="io流"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2019-09-19  <span class="level-item"><i class="far fa-clock"> </i>13 分钟  <i class="fas fa-pencil-alt"> </i>2.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/19/javase/IO%E6%B5%81/">io流</a></h1><div class="content"><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><blockquote>
<p>是用来操作文件内容的。而文件的内容可以分成两个类别：</p>
<ul>
<li>二进制文件，【所有除文本文件之外的文件，比如：音频、视频、图片、word, ppt, excel, …】</li>
<li>文本文件， 能够使用记事本打开的，使用者可以直接读懂的文件。比如：【.txt, .java, .md, …】</li>
</ul>
</blockquote>
<p>注：</p>
<p><strong>不管二进制文件，还是文本文件，其本质都是010101的存储，不同在于它们的编码方式不同。</strong></p>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><blockquote>
<p>是以字符集进行编码的，而字符集是由不同的国家和地区根据自己的情况制定的，并且得到国际上的认可。比如：中国地区的字符集编码就是 GBK,   西区地区的字符集是  ISO-8859-1,  国际编码字符集是 UTF-8， …</p>
<p>每个国家的字符集都是公开的</p>
</blockquote>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><blockquote>
<p>一般来讲，都是由软件厂商自己定义的编码规则，有的是公开的，有的是商业密秘，这些编码规则往往与创建此类格式的软件和解析此类格式软件形成一个闭环。比如：Word格式的文件，就必需使用 微软公司出品的Office办公软件去创建和解析。</p>
</blockquote>
<p>注：</p>
<p>文本文件也是一种二进制文件，之所以把它单列出来，是因为它使用较为频繁，而且不方便使用二进制去处理它，而是使用字符去处理它更为方便。</p>
<p>所以，文本文件是以<strong>字符</strong>为单位进行处理的，在JAVA 的IO流包中，专门提供了一系列的API来处理文本文件，这类流叫字符流。</p>
<p>二进制文件是以<strong>字节</strong>为单位进行处理的，在JAVA的IO流包中，也专门提供了一系统的API来处理二进制文件，这类流叫字节流。</p>
<h2 id="IO流的API"><a href="#IO流的API" class="headerlink" title="IO流的API"></a>IO流的API</h2><blockquote>
<p>包: java.io </p>
</blockquote>
<p><strong>输入流和输出流</strong></p>
<blockquote>
<p>输入和输出都是以JVM为边界的，往JVM内存写入的，叫输入流。</p>
<p>反过来，从JVM内存中向外输出的，叫输出流。</p>
</blockquote>
<p>输入      ||||||||                 |||||||        输出</p>
<p>——–&gt;  ||||||||JVM内存 ||||||||    ———–&gt;</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><blockquote>
<p>有负责读取的输入流和负责写入的输出流</p>
</blockquote>
<h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream        --- 抽象父类</span><br><span class="line">        \- java.io.FileInputStream</span><br><span class="line">        \- java.io.ByteArrayInputStream</span><br><span class="line">        \- java.io.FilterInputStream</span><br><span class="line">        		\- java.io.BufferInputStream</span><br><span class="line">        		\- java.io.DataInputStream     </span><br><span class="line">        		\- java.io.PushBackInputStream</span><br><span class="line">        \- java.io.ObjectInputStream</span><br><span class="line">抽象出一些共性的接口</span><br><span class="line">java.io.DataInput</span><br><span class="line">		\- java.io.ObjectInput</span><br></pre></td></tr></table></figure>

<p><strong>InputStream中的共性方法:</strong></p>
<ul>
<li>int read()    –&gt;  读取1个字节， 效率较低。 返回值 -1表示读到了文件尾[EOF], 非-1的返回值 表示读到的字节本身。</li>
<li>int read(byte[] buf)    —&gt;   尝试最多读取 buf.length个字节，这个方法的返回值表示实际读到的字节个数。如果读到文件尾【EOF】，则返回-1</li>
<li>int read(byte[] buf, int offset, int length)    —&gt; 从offset位置处开始尝试最多读取 length个字节，返回值的意义同第2个方法。</li>
<li>void close()    –&gt; 释放流源释。</li>
<li>available()   </li>
</ul>
<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream        ---- 抽象父类</span><br><span class="line">		\- java.io.FileOutputStream</span><br><span class="line">		\- java.io.BufferedOutputStream</span><br><span class="line">		\- java.io.DataOutputStream</span><br><span class="line">		\- java.io.ObjectOutputStream</span><br><span class="line">		\- java.io.ByteArrayOutputStream</span><br><span class="line">抽象出一些共性的接口</span><br><span class="line">java.io.DataOutput</span><br><span class="line">		\- java.io.ObjectOutput</span><br></pre></td></tr></table></figure>

<p><strong>OutputStream中的共性方法：</strong></p>
<ul>
<li>void write(int byte);   写入单个字节</li>
<li>void write(byte[] buf);   写入 buf.length个字节</li>
<li>void write(byte[] buf, int offset, int length) ;   写入 length个字节</li>
<li>void close()</li>
</ul>
<p><strong>以上这些流又可以分成两种，一种是本身具备流的读写能力的，一种是在原有流的基础上，添加新的功能的流。</strong></p>
<h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><blockquote>
<p>就是本身拥有流的读写能力，比如：FileInputStream / FileOutputStream,  ByteArrayInputStream/ByteArrayOutputStream</p>
<p>从构造器的参数也可以看出，这类流的构造是以”源” 为参数的。</p>
</blockquote>
<h4 id="过滤流"><a href="#过滤流" class="headerlink" title="过滤流"></a>过滤流</h4><blockquote>
<p>本身并没有流的读写能力，它必需借助于节点流来构造。比如：DataInputStream/DataOutputStream, BuffredInputStream/BufferedOutputStream, …</p>
<p>从构造器的参数也可以看出，这类流的构造是以 “流” 来参数。</p>
</blockquote>
<p>这是一种装饰模式，我们来看一下各自的创建过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点流的创建</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"sample.md"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤流的创建</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"sample.md"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设我要构造一个带缓存，能读基本数据类型的流</span></span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    					<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"id.dat"</span>)));</span><br></pre></td></tr></table></figure>



<h3 id="基本类型读写的流：-》-DataInputStream-DataOutputStream"><a href="#基本类型读写的流：-》-DataInputStream-DataOutputStream" class="headerlink" title="基本类型读写的流：-》 DataInputStream/DataOutputStream"></a>基本类型读写的流：-》 DataInputStream/DataOutputStream</h3><blockquote>
<p>利用此类型我可以把基本数据类型持久化到文件中</p>
</blockquote>
<p>案例：</p>
<p>设计一个id从1开始依次增长的算法，要求即使程序退出后，下次再启动时，ID依然是增长的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> index = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> 类名() &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = generateId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用IO流来持久化个值。</span></span><br><span class="line">        <span class="keyword">return</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>首先，如果这个文件不存在，创建这个文件，并且把2L值写入到这个文件中。返回1L</li>
<li>如果文件存在，则先读取这个文件中的值，然后再把这个值+1，写回到这个文件中。</li>
</ol>
<p><strong>详见 IDGenerate.java</strong> </p>
<h3 id="读写对象的流-gt-ObjectInputStream-ObjectOutputStream"><a href="#读写对象的流-gt-ObjectInputStream-ObjectOutputStream" class="headerlink" title="读写对象的流 -&gt; ObjectInputStream/ObjectOutputStream"></a>读写对象的流 -&gt; ObjectInputStream/ObjectOutputStream</h3><blockquote>
<p>这个可以进行对象的读写，要求对象的类型必需要实现 <strong>java.io.Serializable</strong> 接口</p>
<p>这个接口叫对象序列化接口，可以用来持久化对象的状态。</p>
</blockquote>
<p>有关对象的读写操作，有两个细节需要注意：</p>
<ul>
<li>被实持久化的对象必需要实现 <code>java.io.Serialiable</code> 接口</li>
<li>如果某些属性不想被持久化外，则使用<code>transient</code> 修饰符进行修饰。</li>
</ul>
<h3 id="随机读写流-RandomAccessFile"><a href="#随机读写流-RandomAccessFile" class="headerlink" title="随机读写流  RandomAccessFile"></a>随机读写流  RandomAccessFile</h3><blockquote>
<p>它是一个即支持读、也支持写的<strong>节点流</strong>,  它实现了 DataInput和DataOutput 接口。</p>
<p>它还支持移动访问的位置</p>
</blockquote>
<p>常用方法</p>
<ul>
<li>public RandomAccessFile(String path, String mode)</li>
<li>public RandomAccessFile(File path, String mode)</li>
<li>seek(long pos)</li>
<li>getFilePointer()  -&gt;  long</li>
<li>…</li>
</ul>
<blockquote>
<p>主要的打开模式有：</p>
<ul>
<li>“r”  以只读模式打开</li>
<li>“rw” 以读写模式打开</li>
</ul>
</blockquote>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><blockquote>
<p>字符流是以字符为单位处理的流，它实际上是JVM针对字符文件所做的特殊处理。</p>
<p>本质上，有了字节流，就可以处理字符文件，但是，不方便。</p>
</blockquote>
<h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.io.Reader</span><br><span class="line">		\- FileReader</span><br><span class="line">		\- CharArrayReader</span><br><span class="line">		\- FilterReader</span><br><span class="line">			\- PushbackReader</span><br><span class="line">		\- BufferedReader     [*]  带缓存，而且整行的读取   readLine()</span><br><span class="line">		\- InputStreamReader  [字节流到字符流的桥接器]</span><br><span class="line">		\- ....</span><br></pre></td></tr></table></figure>

<p><strong>Reader常用方法</strong></p>
<ul>
<li>read()                读取单个字符</li>
<li>read(char[] buf)               尝试读取buf.length个字符</li>
<li>read(char[] buf, int offset, int length)   尝试从偏移量offset 处 读取 length个字符</li>
<li>close()  释放</li>
</ul>
<p><strong>BufferedReader的方法</strong></p>
<ul>
<li>readLine()   -&gt;  String     此方法以换行符为终止符，但是，返回的字符串是不包含这个终止符。</li>
</ul>
<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.Writer</span><br><span class="line">		\- FileWriter</span><br><span class="line">		\- CharArrayWriter</span><br><span class="line">		\- OutputStreamWriter   [字节输出流到字符输出流的桥接器]</span><br><span class="line">		\- BufferedWriter</span><br><span class="line">		\- PrintWriter    [*] 自带缓存，而且支持整行的写入,  println()</span><br><span class="line">    	\- ...</span><br></pre></td></tr></table></figure>

<p><strong>Writer的常用方法：</strong></p>
<ul>
<li>write(int c)      写入传入的单个字符</li>
<li>write(char[] buf)    把buf 中的字符写入到输出流，写入的是 buf.length个字符</li>
<li>write(char[] buf, int offset, int len)   同上,写入的是 len个字符</li>
<li>close()</li>
</ul>
<h3 id="有关字节流到字符流的桥接口"><a href="#有关字节流到字符流的桥接口" class="headerlink" title="有关字节流到字符流的桥接口"></a>有关字节流到字符流的桥接口</h3><blockquote>
<p>有些标准输入输出设备被定义成了 字节流，可是我们需要把它转换成字符流，这里就可以使用这个桥接器，如下：</p>
<p>BufferedReader br = new BufferedReader(new FileReader(“hello.txt”));  //指向文本的字符输入流</p>
<p>再看：</p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</p>
<p>再看，我有一个指向文本文件字节流, 并且重新指定字符集为 GBK</p>
<p>BufferedReader br = new BufferedReader(</p>
<p>​                        new InputStreamReader(</p>
<p>​                            new FileInputStream(“hello.txt”), “GBK”));</p>
</blockquote>
<p><strong>InputStreamReader的构造器</strong></p>
<ul>
<li>InputStreamReader(InputStream in)    采用默认字符集做转换器</li>
<li>InputStreamReader(InputStream in, String charsetName)   指定的字符集做转换器</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Java/">Java</a><span> </span><a class="article-more button is-small link-muted index-categories" href="/categories/Java/java%E5%9F%BA%E7%A1%80/">java基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/java/">java</a></div><hr></div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="竹影の叶"></figure><p class="title is-size-4 is-block line-height-inherit">竹影の叶</p><p class="is-size-6 is-block">尚未佩妥剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zhuyingcoder" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://gitee.com/zhuyingcoder"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/p/1005056398954554?"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="https://mail.qq.com/cgi-bin/frame_html"><i class="fa fa-envelope"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-23T08:11:15.771Z">2020-07-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/23/javase/%E5%85%83%E6%B3%A8%E8%A7%A3/">javase/元注解</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-11T13:54:50.041Z">2020-07-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/11/developUtils/easyExcel/">developUtils/easyExcel</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-06T03:42:38.907Z">2020-07-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/06/developUtils/git/">developUtils/git</a></p><p class="is-uppercase"></p></div></article><article class="media"><a class="media-left" href="/2019/10/19/frame/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><p class="image is-64x64"><img class="thumbnail" src="https://i.loli.net/2020/07/23/kGaSAiLqIw3Ez56.jpg" alt="mybatis"></p></a><div class="media-content size-small"><p><time dateTime="2019-10-19T14:10:43.000Z">2019-10-19</time></p><p class="title is-6"><a class="link-muted" href="/2019/10/19/frame/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">mybatis</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/frame/">frame</a></p></div></article><article class="media"><a class="media-left" href="/2019/10/19/jvm/jvm/"><p class="image is-64x64"><img class="thumbnail" src="https://i.loli.net/2020/07/23/huavz4GAjmrVxi6.jpg" alt="jvm入门"></p></a><div class="media-content size-small"><p><time dateTime="2019-10-19T14:10:43.000Z">2019-10-19</time></p><p class="title is-6"><a class="link-muted" href="/2019/10/19/jvm/jvm/">jvm入门</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/jvm/">jvm</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">java基础</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/frame/"><span class="level-start"><span class="level-item">frame</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jvm/"><span class="level-start"><span class="level-item">jvm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6/"><span class="level-start"><span class="level-item">开发工具插件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6/Dozer/"><span class="level-start"><span class="level-item">Dozer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javaSE/"><span class="tag">javaSE</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"><span class="tag">java虚拟机</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"><span class="tag">应用容器引擎</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="yejx的博客" height="28"></a><p class="size-small"><span>&copy; 2020 yejx</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请联系zhuyingcoder@qq.com，立即处理<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2020/2/11 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zhuyingcoder"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script src="/js/banner.js"></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>