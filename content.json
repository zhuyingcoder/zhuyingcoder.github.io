{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：软件技术毕业从事JAVA后端开发码农一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 其他 网易云音乐歌单分享 计划2020计划 2020-GOALS 多看些技术文章 额外： 少打游戏 总结： 有优点有缺点，没坚持下来的还是太多。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"风景照 毕业照 部分图片搜集于互联网，侵权请联系，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"内部类、File","text":"内部类 就是类中嵌套另一个类型，根据内部类所处的位置不同，可以有如下形式： 成员内部类 【一个类做为另一个类的普通成员】 静态内部类 【一个类做为另一个类的静态成员】 局部内部类 【一个类做为方法的成员】 匿名内部类 【特殊的局部内部类，也是方法的成员】 成员内部类 【member inner class】语法： 1234567891011121314public class Outer { //属性 private int id; //... public class MemberInner { //属性 //... //方法 //... } //外部类的方法 //...} 优点： 成员内部类可以直接所在外部类的所有成员。 对于私有的成员内部类来说，只供这个外部类使用，外界不能访问这个私有成员。 缺点： 内部的语法比较特殊，不方便调用 静态内部类语法： 123456789101112131415public class Outer { //属性 private int id; private static int count; //静态成员 - 内部类 public static class StaticInner { //属性 //... //方法 //... } //外部类的方法 //...} 优点： 可以直接访问外部类的静态成员 在外部类看来，公开静态内部类可以“上升”为外部类。【利用静态导入】, 这样一来，这个静态内部类即拥有了内部类的优势，也有了外部类的访问特征。 注： 一般来说，使用静态内部类都是为了封装一个“算法/功能”, 这个算法/功能 只为所在的外部类去服务。 局部内部类 [Local Inner Class] 它定义在外部类的成员方法中 语法： 12345678910111213141516171819public class Outer { //属性 private String name; //... public void ma() { //.... //定义一个局部内部类 class LocalInner { //属性 //方法 public void hehe() { .... } } //创建这个局部内部类的实例，并调用它的方法 LocalInner li = new LocalInner(); li.hehe(); }} 注：局部内部类的特点 除了可以访问所在外部类的所有成员外，它还可以访问所在方法的局部变量。在JDK8之前，要求这个局部变量必需是final的，JDK8之后，没有了这个限制。 匿名内部类【Anonymous Inner class】 是没有名字的局部内部类。 它是利用接口或抽象父类来完成的，语法如下： 1234//定义一个接口public interface IHehe { void hehe();} 123456789101112131415161718192021222324public class Outer { //... public void ma() { // IHehe ic = new IHehe(){ //... @Override public void hehe() { ... } }; ic.hehe(); } //或 public void mb() { //... new IHehe() { @Override public void hehe() { //... } }.hehe(); }} 特点： 同局部内部类 文件操作 针对操作系统中的文件进行操作，JDK提供了一个类型:java.io.File 类，这个类型是对文件的一种抽象，它封装了文件的各种操作，包含：创建文件、删除文件、列举文件等，但不能对文件的内容进行读和写。 这个File不是单指狭义的”文件”,它也含文件夹。 因为文件夹是一种特殊的文件，它是包含其它文件或子文件夹的 “文件” JAVA中如何把操作系统中的资源抽象成File的实例？ 首先要理解，操作系统中的资源是指什么？ – 本质上就是路径[PATH], 而路径有两种表达方式： 相对路径 绝对路径 而路径可以使中 字符串 来表达，它是包含一种特定格式的字符串，如： D:\\2020-03\\workspace\\note –&gt; 绝对路径 workspace\\note —&gt; 相对路径 java.io.File中的常用方法 public File(String path) 以操作系统中合格的字符串路径来实例化一个 File的实例 public File(String parentPath, String path) 在父目录parentPath下面创建一个 File实例 public File(File parent, String path) 同上 … …","link":"/2019/09/19/javase/%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81File/"},{"title":"NIO","text":"Channel [java.nio.channels]1234567891011121314Channel \\- ReadableByteChannel 可读的通道 \\- ScatteringByteChannel 把同一个通道中的字节读到多个字节缓存中，这个过程叫分散 \\- WriteableByteChannel 可写的通道 \\- GatheringByteChannel 把多个缓存中的字节写入到同一个通道中，这个过程叫聚集 \\- ByteChannel \\- SeekableByteChannel 可以保持并调节位置的通道 \\- FileChannel 针对文件的通道，不支持配置为非阻塞模式 \\- SelectableChannel 可通过Selector复用的通道,提供了配置非阻塞的方法 \\- AbstractSelectableChannel \\- DatagramChannel 针对网络的UDP协议,支持 非阻塞模式 \\- SocketChannel 针对网络的TCP协议，这个类是做客户端，支持 非阻塞模式 \\- ServerSocketChannel 针对网络的TCP协议，这个类是做服务端的，支持 非阻塞模式 Channel的核心方法 从通道中读取数据到缓存中 int read(ByteBuffer buffer) 把通道中的字节数据存储到缓冲中，并返回实际读到的字节数。 long read(ByteBuffer[] bufArr) 把通道中的字节数据分散读到多个缓冲中，并返回实际读到的字节数。 long position() 获取通道中当前文件指定的位置 FileChannel position(long pos) 设置通道中文件指针的位置，这个值可以大于文件大小，但是，只是读的话，并不改变文件大小，如果 写入，则文件会生长，以适应新的大小。 long size() 返回此通道的大小，其实就是文件通道所指向的文件的大小。 把缓存中的数据写入到通道 int write(ByteBuffer buffer); long write(ByteBuffer[] bufArray); Buffer 一组固定大小的连续空间，用来存储从通道中读到的数据。 它的操作主要就是： 缓存中数据的读写 缓存中各种标记位置的控制 类的结构 1234567891011Buffer \\- ByteBuffer \\- HeapByteBuffer 非直接缓存 \\- MappedByteBuffer \\- DirectByteBuffer 直接缓存 \\- CharBuffer \\- ShortBuffer \\- IntBuffer \\- LongBuffer \\- DoubleBuffer \\- FloatBuffer 注：默认情况下，都会分配非直接缓存，如下： 123ByteBuffer buffer = ByteBuffer.allocate(1024); //非直接缓存ByteBuffer buffer2 = ByteBuffer.allocateDirect(1024); //直接缓存 常用方法 int position() 返回缓存中当前位置 int limit(); 返回缓存中限制的位置 int capacity(); 返回缓存的容量 mark() 在当前位置进行标记 flip() 反转，用来读写转换中。 clear() 清空缓存，并没有清空数据，只是重置了 mark, position, limit的值 compact() 是一个可选方法，压缩 wrap(byte[] buf) 以指定的字节数组来填充这个缓存，缓存的大小capacity就是 buf.length 有关这4个属性，满足： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Selector Lambda 表达式 它本质是JDK提供给程序员在编写代码语法上的一种便捷方式，也叫语法糖。 JAVA的语法规范上，方法的参数是不能以代码块[函数] 进行传递的。不像 javascript, 那我们如何才能写出传 递代码块的方法呢？ JDK8中，引入了Lambda表达式以及函数式接口，就是为解决这个问题而存在的。 12345678public void ma(只有1个方法的接口 identifier) { // System.out.println(\"ma的功能操作....\"); //中间这此代码，此时，做为ma方法编写者，我不知道这个地方要写什么，将来谁调用这个方法，谁知道，那就要求，调用者要把这个代块给 传进来给我。 identifier.xxx(); //相当于完成了 代码块 的传递 System.out.println(\"ma的功能操作.... \")} 注： 上面的方法中的参数 “只有1个方法的接口” 是JVM为了达到代码传递的目的，而准备的一个特殊的接口，这个接口在JDK8中，叫函数式接口，使用一个注解来标注 @FunctionalInterface 函数式接口 在JDK8中规定，某个接口上面打上了 @FunctionalInterface，就表示这个接口就是函数式接口，通过它就可以来接收代码块的传递，而且为了语法的方便性，才推出了 Lambda 表达式。 另外，由于在JDK中，有很多接口都是单一方法的，所以，JVM还规定，只有接口中只有唯一的抽象方法时【除继承于Object中的方法外】，即使你没有显示地使用 @FunctionalInterface 注解，JVM也认为它就是 函数式接口。 案例1234567891011121314151617181920public interface Ia { void ma();}public class TestIa { public void mb(Ia identifer) { System.out.println(\"before invoke ia ... \"); //回调 Ia 接口的方法 identifer.ma(); System.out.println(\"after invoke ia ...\") } public static void main(String[] args) { // TestIa ti = new TestIa(); ti.mb(() -&gt; {System.out.println(\"in method ma()....\");} ); }} Lambda 的语法规范 (Type param1, Type param2, …., Type paramN) -&gt; { ​ //代码块 } 这个语法可以简化如下： 参数的类型可以省略，就变成了 1(param1,param2,...,paramN) -&gt; { } 如果参数的个数只有1个时，小括号也可以省略 1param -&gt; {} 如果代码块中只有1条语句，大括号也可以省略 1param -&gt; one_statement; 注：所有使用匿名内部类的地方，都可以使用Lambda表达式来改写 方法引用 它是Lambda表达式的另一种特殊写法，本质上还是 Lambda表达式， 改写条件 Lambda表达式当中只有单一一条语句 这条语句是调用已有的方法 如： 12345List&lt;String&gt; list = Arrays.asList(&quot;jack&quot;,&quot;ann&quot;,&quot;solo&quot;);// Lambda表达式list.forEach((element) -&gt; System.out.println(element));//方法引用list.forEach(System.out::println); 在Lambda表达式中访问局部变量的限制 在JDK7之前，匿名内部类中可以访问它所在方法的局部变量，但是，要求这个局部变量要使用 final 修饰，在JDK7之后，这个final可以不写，但是，在匿名内部类当中，不能去修改这个局部变量。 同理，LAMBDA表达式本身就是 匿名内部类的语法优化，所以，在Lambda表达式内部，同样不能修饰所在方法的局部变量。 Lambda表达式的操作包 java.util.function java.util.stream","link":"/2019/09/19/javase/NIO%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"反射和注解","text":"反射 Reflection 提供了一套给程序员用来窥探字节码内部结构的机制。在JDK5开始引入的。 通过反射，我们可以把字节码反编译成源文件。 所以，反射的程序都是从 字节码开始的。 字节码 就 是由 javac 编译 .java源文件后形成的文件， 以 .class 为扩展名。 那么 JVM 是如何去管理这个 字节码文件的。 当.class文件被JVM加载进入内存后，这个字节码就会由JVM进行管理，而JVM中，需要一个类型来表达字节码，这个类型就是 java.lang.Class java.lang.Class 它就是一种JAVA数据类型，同 Scanner, LocalDate 等一样。 它的实例是用来表达字节码本身的一种对象。每个JAVA类型在被JVM加载进入内存后，JVM都会创建此类唯一的 Class实例。 比如：JVM加载了Computer类进来，则JVM中就会创建一个 Computer的Class 实例。以此类推，加载了 LocalDate, Scanner, System, String等等，则在JVM就会对应创建 LocalDate的Class实例、Scanner的Class实例、System的Class实例、String的Class实例。 如何获取 Class 实例？有三种方式可以获取: 通过 Class.forName(String qualifiedName) 来获取， 程序员需要指定目标类型的全限定名【包名. 类名】 通过 类名.class 来获取 通过 对象.getClass() 来获取 以上三种方式，对于同一个类型来说，得到的结果是一样的【JVM中，同一个类的Class实例是唯一的】 通过类的Class实例，我们可以获取什么？ 获取此类的包结构 —&gt; getPackage =&gt; java.lang.Package 获取此类导入的类型 –&gt; 类的修饰符 –&gt; getModifiers() =&gt; int 实现了哪些接口 –&gt; getInterfaces() =&gt; Class&lt;?&gt;[] 本身又是 Class 实例 继承的父类 –&gt; getSuperclass() =&gt; Class&lt;? super T&gt; 本身又是 Class 实例 泛型信息 –&gt; getTypeParameters() =&gt; TypeVariable[] 。。。 属性信息 –&gt; getFields() =&gt; Field[] 属性修饰符 –&gt; getDeclaredFields() =&gt; Field[] 属性类型 –&gt; getField(String fieldName) =&gt; Field 属性名 构造方法信息 –&gt; getConstructors() =&gt; Constructor[] 修饰符 –&gt; getDeclaredConstructors() =&gt; Constructor[] 参数列表 方法信息 –&gt; getMethods() =&gt; Method[] 方法修饰符 –&gt; getDeclaredMethods() =&gt; Method[] 方法的返回类型 –&gt; getDeclaredMethod(String mName, Class… params) =&gt; Method 方法名 方法的参数列表 方法申明抛出的异常列表 反射API java.lang.reflect 包 为什么要用反射？ 希望写出更通用的代码。 动态地给目标类添加新的功能，而不需要改变源码【代理 Proxy】 注解 Annotation [也叫标注] 用来提供代码的辅助信息，比如配置信息，以及一些需要编译器进行检查的信息 语法： 123public @interface 注解名 { } JDK内置的注解 在 java.lang中有3个 @Override 用来告诉JVM的编译器去检查方法是否符合重写的规范 @Deprecated 用来告诉JVM的编译器，这个类或方法已经过时了 @SuppressWarnings 用来告诉JVM的编译器，对所指定的一些警告信息保持静默. 它包含： “serial” 针对实现了Serializable接口的类型，没有给出versionUID时的警告 保持静默 “unused” 针对定义了变量，但是这个变量从未使用过的警告保持静默 “unchecked” 针对一些未检查的警告保持静默 … “all” 所有警告保持静默 JDK7和8中，又添加了2个 @SafeVarargs @FunctionalInterface 把某个接口标注为函数式接口。 在java.lang.annotation中有4个, 这4个也叫 元注解[meta annotation, 就是用来标注其它注解的注解] @Documented – 表示被此元注解修饰的注解可以进入到 javadoc的文档中 @Inherited – 被此注解修饰过的注解使用类，如果这个类有子类的话，则子类将可以继承父类中的注解 @Retention – 表示规定注解可以保留在什么层面上，有3个层面可以选择： SOURCE – 表示注解只保留在编译期间，在字节码层面看不到这个注解。 CLASS – 表示注解不止在编译期间，在字节码层面也存在，但是，JVM不能读取。 RUNTIME – 表示注解不止在编译期间，在字节码层面也存在，而且JVM可以读取。 注：如果我们开发注解，没有指定 @Retention 的话，则默认是 CLASS @Target – 表示注解可以修饰的类型是什么， 它同样有一个枚举来指定，包含如下值： TYPE ANNOTATION_TYPE METHOD CONSTRUCTOR FIELD … 注：如果我们开发注解，没有指定@Target的话，则默认是 所有地方都可以使有。 一般来说，我们开发注解的话，最少应该要使用 @Retention 和 @Target 注解的特点 与枚举一样，它也是一种类型，而且所有的注解都会自动实现 java.lang.annotation.Annotation 接口 所以，可以这么说，我们开发的每一个注解，都是 Annotation 接口的实现类。 Annotation 接口 详见API 使用注解的语法12345678910111213@注解名如果这个注解有参数的话，则给相应的参数@注解名(参数名=值,参数名=值) //如：@SuppressWarnings(value={\"serial\",\"unused\"})public class Hello { @Override public void ma() { //... }} 注解有什么用？ JDK自带的注解，JVM会对它进行解析，并给出相应的意义。 我们自已开发的注解，就需要程序员自己编写 解析代码，并指定相应的意义。","link":"/2019/09/19/javase/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3/"},{"title":"多线程","text":"什么是进程 正在运行的程序，现代的操作系统都是多任务【多进程】、多用户的 JVM就 是一个进程【process】， 当我们启动JVM时，就是启动了一个进程 什么是线程 运行在进程内部的一种资源，同样也是由OS负责调度， 一个进程中的所有线程都会共享此进程的资源，也有线程所独享的资源。 理论上来说，进程中可以启动很多个线程。 可以这么说，现代的软件都是基于线程的。 一个软件程序可以有多个进程，每一个进程又可以包含多个线程 注：不管是进程，还是线程，都是操作系统级别的资源。 所以，线程和进程执行时，都需要OS的调度，所谓调度，就是给进程或线程所要执行的环境，这个环境就包含两个东西： CPU时间片， 把CPU的执行时间拆分成一个一个的小时间段。 内存，因为硬盘的运行整度跟不上CPU，而CPU的存储空间又不可能做到很大。 在JAVA中，如何去开发一个线程类方式一，直接继承 java.lang.Thread 类 public Thread() public Thread(Runnable r) 12345678public class MyThread extends Thread { @Override public void run() { //..... //就是此线程被OS调度后要执行的代码 }} 123//创建线程对象，启动线程Thread t = new MyThread();t.start(); //启动线程 注： 当我们启动线程时，不是调用run方法，而是调用 start 方法。 start() 表示，JVM告诉OS, 我这里有一个线程对象，需要你的调度。 一个线程一旦调用了start方法，表示进入了 “可运行态”，只有当OS分配了CPU时间片后，才会真正执行，也就是进入了“运行态”。 方式二，实现 java.lang.Runnable 接口，并以这个接口的实例做为参数来构造 Thread对象 首先，开发一个类来实现 Runnable 接口，如下： 1234567public class MyRun implements Runnable { @Override public void run() { //... //.. }} 其次，创建一个Thread对象，并以 MyRun的对象做为参数，如下： 123//...Thread t = new Thread(new MyRun());t.start(); //启动线程， 不是调用 run 方法 Thread中的常用方法 join() 方法，当前线程如果调用另一个线程的join方法，表示当前线程进入阻塞，直到被调用了join方法的线程运行结束。 yield() 方法，当前线程调用了yield方法后，表示当前线程立即从运行态回到可运行态，再次等待CPU的调度。 sleep() 方法，当前线程调用了此方法，则当前线程进入阻塞。 interrupt() 方法，中断方法，也就给目标线程发送中断信号. 目标线程即使处在阻塞状态，也能接收中断信号，一旦接收到中断信息，立刻打破阻塞。 JVM进程中的线程 当JVM进程启动后，就会启动2个线程，其中 主线程，也叫main线程，它负责调用你的程序中的main方法 垃圾回收线程，也叫GC线程，它是一个后台守护线程，也叫Daemon线程。 当JVM进程中，所有的非守护线程都结束后，JVM进程就结束。 所以，在我们之前所开发的所有案例中，当main方法执行结束，JVM进程就结束了。 线程的状态 初始态, 创建了一个线程对象，没有调用start之前的状态 可运行态【Runnable】，调用了start()方法之后 运行态【Running】, 正在执行中的线程 终止态【Terminate】, 线程执行结束 阻塞态【Blocking】, 又分成如下3种情况 普通阻塞，比如：调用了 sleep()方法，join()方法， 等待用户的输入。 锁池阻塞，当一个线程拿不到目标资源的互斥锁时，就会进入到目标资源[对象]的锁池中阻塞 等待队列，当多个线程进行通信息，当前线程调用了目标资源[对象]wait()方法，则当前线程进入等待队列阻塞，直到其它线程调用了目标资源的notify或 notifyAll方法。 锁资源 如果我们的代码使用了同步关键字[synchronized], 则就需要使用临界资源对象来达到互斥的目的，如果每线程都拥有各自的一份临界资源，则这个临界资对象就不能在线程间才互斥。 锁 同一种互斥资源，它是对象所拥有的 synchronized关键字 用来做代码的同步的，有两种语法： 直接加在方法的修饰符位置。这表示采用当前对象做为临界资源对象。 使用 synchronized(对象) 方式，这种方式可以自己指定临界资源对象。 【*****】 线程间的通信前提： 一要要有同步 要有临界资源的抢占 使用wait()和notify()或notifyAll() 来完成 死锁 【deadLock】 多个线程之间互相申请对方的互斥锁资源时，就会产生死锁。 写多线程代码时，要尽可能地避免。 如果有多个临界资源时，每个线程在申请临界资源的锁时，尽量保持顺序一致。 网络编程 java.net 包, 主要包含如下类型 ServerSocket 开发基于TCP协议的服务端应用程序 Socket 开发基于TCP协议的客户端应用程序 DataGramSocket 开发基于UDP协议的应用程序 TCP 是网络通信协议中的一种，处于TCP/IP网模型中的传输层。全称是：Transfer Controll Protocol, 传输控制协议， 它是一种面向连接的网络协议，是安全的。它的建立需要经过三次握手，以保证连接的可靠性。 对于JAVA的网络API而言，程序员是不需要理解底层的网络机制，JDK的API都帮我们封装好了。这个封装好的类型就是 Socket和ServerSocket UDP 也是网络通信协议的一种，而且也是处于TCP/IP网络模型中的传输层，与TCP是一样。所不同的是，UDP是非面向连接的，而且不保证数据传输的可靠性【有可能会丢包】，适合做 视频会议、网络课堂等 应用。 开发服务端 创建ServerSocket对象 进行监听，等待客户端的连接，调用 accept(), 连接成功，就会返回 Socket 创建一个线程为客户端进行服务，并以 Socket 做为参数 开发客户端 创建 Socket 对象， 要指定你要连接的服务端的IP地址和端口 通过Socket来获取输入/输出流或者 通道[Channel] 读、写 数据 端口是什么 ？ 每个需要网络通信的进程都需要唯一的端口，系统会自动为这些进程分配端口，最多可以分配出 65536个。 有些常用的网络协议，会固定占用一些端口，在OS中，1024以下的端口都是被系统预先征用的，我们的应用程序的端口最好超过这个大小。","link":"/2019/09/19/javase/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"title":"核心API","text":"类之间的关系横向关系 组合关系 【关系较强】 是关联的一种，两个类之间的关系较强，属于整体与局部关系。 局部不能脱离整体单独存在，在创建整体对象时，局部被一起创建出来。 也是HAS A 关系 如： 123456789101112131415161718public class Person { private String name; private Date birth; // private Heart heart; // // public Person(String name) { this.name = name;// this.birth = new Date(); //也是组合 // this.heart = new Heart(); //这个Heart不是由外部传入的，而是在创建整体对象时，它自己来创建局部对象。 } //...}//public class Heart { //...} 注： 组合关系的ＵＭＬ图形是：实线+实心菱形 聚合关系 【关系比组合关系略弱】 也是关联关系的一种，两个类之间的关系稍弱，两个类在语义上是”平等”。 两个对象可以单独存在，在创建主对象时，辅助对象不需要被创建，而是由外部传入。 也是HAS A 关系 123456789101112131415161718192021public class Person { private String name; private Date birth; // private Heart heart; // private Address homeAddress; //家庭住址 // public Person(String name, Address homeAddress) { this.name = name;// 聚合 this.birth = new Date(); //也是组合 // this.heart = new Heart(); //这个Heart不是由外部传入的，而是在创建整体对象时，它自己来创建局部对象。 // this.homeAddress = homeAddress; //聚合，对象由外界传入。 } //...}//public class Heart { //...} 注： 聚合关系的UML图形是：实心线+空心菱形 依赖关系 【关系最弱】 它是一种“USE A” 关系，表示一个类使用了另一个类，这种方法往往以局部变量的方式出现在代码中，如：我们在程序经常使用一些工具类或辅助类，都是这种关系。 如： 1234567891011public class IAFactory { public static IA getInstance() { //... //... }}public interface IA { //...}// IAFactory与IA 的关系就是 依赖关系，IAFactory依赖于 IA 以上三种关系由强到弱分别是： 组合，聚合，依赖 注： 依赖的UML图形是：虚线+箭头 纵向关系 继承关系 它是 “IS A” 的关系。 它的UML图形是：实线+空心三角形 实现关系 它也是”IS A “ 的关系。 它的UML图形是： 虚线+空心三角形 三大类型的操作数字型 8大基本类型的包装类 12345678byte --&gt; Byteshort --&gt; Shortint --&gt; Integerlong --&gt; Longdouble --&gt; Doublefloat --&gt; Floatchar --&gt; Characterboolean --&gt; Boolean 以上8种基本类型与对应的对象类型之间可以实现自动解封箱[auto boxing/unboxing]。 如： 1234567int i = 9;Integer j = i; //ok, 自动封箱Integer k = new Integer(i); //ok, 手动封箱int m = k; //ok, 自动解箱//注：虽然可以自动解封箱，但是，它们还是有区别的，如：j = null; //oki = null; //compile error 这8种基本类型与对象类型以及字符串形式如何转换？ 以 Integer 为例 把 int 转换成字符串 12345int i = 9;String istr = String.valueOf(i);或：String istr = i.toString(); //Compile ErrorString istr = Integer.valueOf(i).toString(); //ok 把字符串转换成整数 12345678String istr = \"19\";String jstr = \"0xff3\";int i = Integer.parseInt(istr); //okint j = Integer.parseInt(jstr, 16); // //或1int i = new Integer(istr).intValue(); //ok//或2int i = Integer.valueOf(istr).intValue(); //ok 抽象父类 Number 是为了以统一的方式来使用各种不同的数字类型而准备的。 为了扩展而存在的。 相关的包 java.lang包 java.text包 java.math包 数字的格式化 日期型 在JDK8之前，日期相关的API分布： java.util.Date, TimeZone java.sql.Date, TimeStamp, Time, Calendar , GregorianCalendar java.text.DateFormat , SimpleDateFormat java.util.Date 常用方法： public Date() 以当前的系统时间来构造日期对象 public Date(long t) 以指定毫秒数来构建日期对象 java.util.Calendar 和 GregorianCalendar 常用方法： getInstance() 获取Calendar的实例，是一个工厂方法 set(int type) 设置日历对象中的指定成员，这个成员由 type指定，这个type是Calendar定义的常量，如：YEAR, MONTH, DAY_OF_MONTH, …. get(int type) 获取日历对象中的指定成员，这个type同上。 getTime() 获取此日历对象中的日期，返回一个 Date setTime(Date d) 给此日历对象设计一个新的日期。 DateFormat和SimpleDateFormat 常用方法： public SimpleDateFormat(String pattern) 构造方法，根据指定 的模式来创建SimpleDateFormat对象 format() 方法，格式化日期对象，返回字符串 parse() 方法， 解析方法，把字符串解析成日期对象，并返回 JDK8中的全新日期处理API所在的包： java.time java.time.format java.time.temporal … 主要的类型 【这些类型都是不可变的，线程安全的】 LocalDate 处理年月日的类型 LocalTime 处理时、分、秒 LocalDateTime 年月日，时分秒 Duration 计算时间分和差距 Period 计算年月日 的差距 Clock 可选类 … 字符串作业作业一、我们需要设计一组类来操作图书类[Book]数据，包含添加图书、查询图书、删除图书、统计数量、清空等操作。 其中，Book实例类包含如下属性 id 图书名 图书作者 isbn 【表示图书的编码】 为了更好地体现OO的思想，设计一个图书业务接口如下： public interface IBookService { 123456789101112131415void addBook(Book b); //添加图书void deleteByIsbn(String ibsn); //void deleteByAuthor(String author); //void updateBook(Book b); //附加题int size(); //统计书的数量void clear(); //清空所有图书Book selectByIsbn(String isbn);Book[] getAllBooks(); //获取所有图书 } //请写一个业务接口的实现类，完成以上所有的业务方法。 并提供测试。","link":"/2019/09/19/javase/%E6%A0%B8%E5%BF%83API/"},{"title":"注解解析程序","text":"Annotation Process/Parse Tool, APT, 它是我们利用反射API进行注解处理的一种程序。 注解是通过代码的方式进行程序辅助的，JDK中提供了一些注解，包含元注解 @Override @SuppressWarnings @Deprecated @SafeVarargs JDK7加入 @FunctionalInterface JDK8加入 @Documented @Inherited @Retention(value=RetentionPolicy.XXX) Retention.SOURCE Retention.CLASS Retention.RUNTIME @Target(value={ElelmentType.XXX, XXXX,XXXX}) ElementType.METHOD ElementType.TYPE … 注：元注解是用来修饰其它注解的注解 自定义注解12345//使用元注解修饰public @interface 注解名{ //参数的定义 类型 参数名() [default 默认值]} 注解中参数的类型有以下几种： 基本类型 String 枚举 Class 注解 以上类型的数组 代理 可以在不改变原有对象源代码的基础上，添加新的功能。 它的机制： 代理对象与被代理对象会实现同一个接口 利用JDK中提供的 Proxy和InvocationHandler 接口来实现。 静态代理 使用组合模式来实现 案例： //先定义一个接口 Movable 123public interface Movable { void move();} //创建一个实现类 12345678public class Car implements Movable { @Override public void move() { System.out.println(\"汽车在移动....\"); }} //调用者 1234567public class UseMove { public static void main(String[] args) { //创建对象 Movable m = new Car(); m.move(); }} //要求：在不改变 Car类的实现方法move()的情况下, 如何给这个car的move()添加新的操作? 解决思路1，采用静态代理来做 开发一个代理类，这个代理类同样要实现 Movable 接口 1234567891011121314151617public class MoveProxy implements Movable { private Movable target; public MoveProxy(Movable target) { this.target = target; } @Override public void move() { //... System.out.println(\"汽车在启动之前的检查操作\"); //调用被代理对象的真正业务 target.move(); //。。。 System.out.println(\"汽车移动完成之后的操作\"); }} //现在，调用者代码变成： 1234567public class UseMove { public static void main(String[] args) { //创建对象 Movable m = new MoveProxy(new Car()); m.move(); }} 注：在调用者这端，拿到的是 Car的代理对象 注：静态代理可以达到我们的目的，但是，它的通用性和扩展不够，当接口中多出1个方法或再多实现一个接口时，不光被代理对象要进行修改，我们的静态代理类也要修改。 解决思路2，采用动态代理 利用JDK中自带的 Proxy和InvocationHandler 两个类型来完成。 要求： 目标对象一定要有实现的接口，没有实现接口的目标对象，JDK自带的Proxy，没有能力为它生成代理对象。 java.lang.reflect.Proxy常用方法 Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler); 其中 ClassLoader 表示目标对象的类加载器 Class&lt;?&gt;[] 表示目标对象所实现的接口类型，可以有多个，所以才是数组 InvocationHandler 表示创建出来的代理对象要执行的代码，由程序员填入。 java.lang.reflect.InvocationHandler常用方法 Object invoke(Object proxy, Method m, Object[] args); 其中 proxy 代理对象 Method 就是目标方法 args 就是目标方法的参数","link":"/2019/09/19/javase/%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86/"},{"title":"流程控制","text":"也就是程序代码的结构，主要有三种 顺序结构 从上至下的代码执行结构，没有分支。 分支结构 程序代码在执行时，根据“判断”来决定进入不同的分支之中，java语言提供两种语法： if语句语法： 1234567891011121314151617if(条件判断) { //代码块}或者：if(条件判断) { //代码块1} else { //代码块2 }或者if(条件判断1) { //代码块1} else if(条件判断2) { //代码块2 } else { //代码块3 } switch 语句 也是一个多分支语句结构，它和if不同在于，switch只支持 等值比较 判断，不像if语句那般灵活。 语法： 123456789101112131415switch(变量因子) { case 值1: //代码块1 [break;] case 值2: //代码块2 [break;] .... case 值N： //代码块N [break;] default: //默认代码块 [break;]} 注： 变量因子与case的值只能等值比较。所以，变量因子的类型只能是如下类型： byte, short, char, int 在JDK5.0后，开始支持 枚举[enum] 在JDK7.0后，开始支持 String 循环结构for循环语法： 1234567891011121314151617for(expr1;expr2;expr3) { //循环体}注：expr1 表示循环初始化语句，它只执行1次，可以省略expr2 表示循环条件判断语句，它随循环执行，如果成立，则执行循环体，不成立，则退出循环，可以省略expr3 表示循环变量因子变化语句，它随循环执行。，可以省略三个表达式的执行顺序：first: =&gt; expr1 [1次]second: =&gt; expr2 [N次]third: =&gt; 循环体 [N次]last: =&gt; expr3 [N次]所以，如果三个表达式都省略的话，则变成：for(;;) { //循环体 -- 死循环} 比如，我们要循环5 次 123456789101112for(int i = 0; i &lt; 5; i++) { System.out.println(\"i = \"+i);}//在这里，变量i 就不可访问 了改写成：int j = 0;for(; j &lt; 10; j+=3) { System.out.println(\"j = \"+j);}//在这里，变量j 还是可以访问 的。System.out.println(\"此时的j的值是：\"+j); //12 注：任何局部变量的可见范围只存在于定义它的那一对大括号之中。出了这一对大括号，变量就消失了。 循环也可以嵌套 12345678910for(int i = 0;i &lt; 10; i++) { // for(int j = 0; j &lt; 10; j++) { // for(int k = 0; k &lt; 5; k++) { // } }} //例： 打印输出一个99法则表 – 题目： 打印输出如下的数字： 1*1 = 1 11*11 = 121 111*111 = 12321 …. 111111111*111111111=12345678987654321 – 题目： 打印如下数字： 1*8 + 1 = 9 12*8+2=98 123*8+3=987 1234*8+4=9876 12345*8+5=98765 …. 123456789*8+9=987654321 while循环语法： 123456789while(条件){ //循环体}同样，循环5次int i = 0;while(i &lt; 5) { System.out.println(\"i = \"+i); i++} while 循环和for循环的使用场景 如果能确定循环次t数，建议使用 for循环 如果是迭代数组或集合，建议使用 for循环 如果事先并不知道循环次数，建议使用while循环 do while循环语法： 12345678910do { //循环体} while(循环条件);//写一个循环5次的代码int i = 0;do { System.out.println(\"i = \"+i); i++;} while(i &lt; 5); 注：do while适合交互式菜单的开发，一般是配合 switch 使用。 break语句和continue语句 在循环体中，进行控制的语句，其中 break 语句表示打破最接近于自己的那一层循环。 continue 语句表示结束本轮循环，当然，它也只影响最接近于自己的那一层循环。 例： 12345678910111213for(int i = 1; i&lt;= 9;i++) { System.out.println(\"i = \"+i); if(i % 3 == 0) { break; }}与for(int i = 1; i&lt;= 9;i++) { if(i % 3 == 0) { continue; } System.out.println(\"i = \"+i);} 在Eclipse中，配置代码注释的模板类型转换隐式类型转换 就是指系统自动帮助我们进行类型转换，程序员无需做任何操作，一般来说，小范围类型在需要时，会自动向大范围类型 隐式转换。 如： 1234char c = 'A'; //字符型变量 cint i = c; //ok, 此时，就发生了隐式类型的转换。long a = 100; //此时，就发生了隐式类型的转换。 强制类型转换 当你需要把大范围类型的变量赋值 给小范围 类型时，就需要做强制类型的转换 语法： (类型)变量或表达式 如： 1234567891011byte b1 = 12;byte b2 = 19;byte b3 = b1 + b2; //compile error//使用强制类型转换byte b3 = (byte)(b1 + b2); //ok//再比如：int i = 97;char c = i; //compile error//使用强制类型转换char c = (char)i; //ok 格式化输出/打印 普通的打印输出，调用的是：System.out.println()或System.out.print() 方法 格式化打印输出，调用的是：System.out.printf() 方法 如下： 123456789101112131415int i = 9;int j = 10;//打印输出 i*j的结果System.out.println(i+\"*\"+j+\"= \"+(i*j));//这种打印有如下缺点：1. 拼接时容易出错2. 考虑优先级3. 字符串拼接性能较低，因为会产生很多临时对象现在，我们使用格式化输出，如下：System.out.printf(\"占位符 * 占位符 = 占位符\\n\",i, j, i*j);//使用这种方式，上面的三个缺点都可以消除，同时，格式化输出还有如下优点：1. 可以指定占位符的字符宽度2. 可以设定对齐方式3. 针对浮点数，还可以指定精度 占位符的语法1%[arguments_index$][flag][width][.precision]conversion 有关 conversion 的字母 s –&gt; 字符及字符串 d –&gt; 整数 f –&gt; 浮点数 b –&gt; 布尔值 t –&gt; 时间或日期，它还需要配合另一个字母【后面在日期格式化再细说】 % –&gt; %本身 … 如： 1234int i = 9;int j = 10;//打印输出 i*j的结果System.out.printf(\"%d*%d=%d\\n\", i, j, i*j); 有关 width 指定占位符的宽度，如果目标值超过了宽度，则使用目标值的真实宽度。如果目标值没有达到指定的宽度，则使用空格来填充，并且依赖于对齐方式【flag的值】 有关flag 一个标记符号，默认是右对齐的，使用 - 表示左对齐 有关 精度 针对浮点数才有意义。 有关占位符与变量的对应顺序 默认情况下，替换变量的个数与占位符个数是一一对应的。 如果，替换变量的个数与占位符的个数不一样时，就可以使用 arguments_index$ 来指定。","link":"/2019/09/19/javase/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"继承和多态","text":"封装的理念 针对同一个类中的属性和方法的封装策略： 属性应该私有化，业务方法应该公开化。 针对类中的业务方法的封装策略： 把属性、构造、getter/setter方法和业务方法封装在一起。这个优点是类的内聚性高，类的使用简单。缺点是扩展性差、伸缩性差，所以，适合功能单一的类型。 把属性、构造、getter/setter方法单独封装成一个实体类，这个类的对象就成为数据的载体，而把针对此类型的操作单独封装成业务类型，这个业务类型的对象就是功能/方法的载体。 这个优点就是扩展性好，缺点就是学习难度较大，对象之间的关系和调用比较复杂。适合大型的应用设计。 继承 就是指从超类那里继承可以继承的成员。 除了超类中 private 修饰的成员外，其它的成员都被子类所继承，也就是子类可以直接使用。 关键字12345extends语法：public class 类型1 extends 类型2 { //...} 继承的特点 单继承 具有传递性 所有的对象类型都直接或间接地继承于 java.lang.Object 注：一个类如果没有显示地继承另一个类，则这个类就自动继承 java.lang.Object 类 为什么要用继承 最原始的原因当然是为了 代码复用, 但是，通过继承来达到代码复用是要付出很大代价的。 在现在的开发中，如果仅仅是为了代码复用，建议采用 组合/聚合模式，而不是继承。 何时使用继承？ 当类之间的关系，满足IS A的关系。 这种情况下，应该使用继承。 如： 我们有一个 水果类 Fruits, 还有一个苹果类 Apple, 很显然， Apple IS A Fruits 是满足的。 所以，代码可以这么设计： 12345678//水果类public class Fruits { //}// 苹果类public class Apple extends Fruits { //} 有了继承后，父子类中的属性该如何设计？ 共性设计在父类中 个性设计在子类中 子类的构造器 在子类的构造器中，默认总是会调用父类的空参构造器，当然，我们可以选择父类构造器的调用。 有了父子类后，创建子类对象的过程总是递归地按如下3步先创建父对象 申请堆空间 给属性赋默认值 调用构造方法 如果在子类的构造器没有指定调用父类的哪个构造器，则总是会调用父类的空参构造，所以，如果父类没有提供空参构造，则子类的构造器会报编译错误。 注：同this调用构造器一样，super() 也必须放在构造器中的第一行位置。 编译时类型和运行时类型 编译时类型是指变量在编译期间的类型，可以是 对象类型本身，也可以是父类类型。所以，Object 类可以做为任意对象的编译时类型。【一切皆对象】 运行时类型，是指这个对象的真正类型，它在创建的那一刻就确定了，不会再改变。 方法的重写[override] 只能在父子类之间存在。 方法重写的要求： 方法名必须一样 方法参数必须一样 方法的修饰符，子类的访问控制修饰符必需不能小于父类的访问控修饰符的范围 方法的返回类型，子类的返回类型要么与父类一样，要么是父类返回类型的子类。 方法的异常列表，子类所申明抛出的异常类型要么与父类一样，要么是父类申明抛出异常类型的子类。 多态 同一种类型【编译时类型】的对象，调用相同的方法，真正执行的行为不一样，这就是多态。 在java在，要体现多态性，需要满足如下条件： 要有继承 要有方法的重写 如： 1234567891011121314151617181920212223public class Shape { ... public double girth() { return 0.0; } public double area() { return 0.0; }}//子类1public class Circle extends Shape { private float radius; @Override public double girth() { return 2 * Math.PI * this.radius; } @Override public double area() { return Math.PI * Math.pow(this.radius, 2);}}//子类2public class Rectangle extends Shape { private float length; private float width; @Override public double girth() { return 2*(length + width); } @Override public double area() { return length * width; }} //表现多态性 123456789101112Shape c = new Circle(4.5);Shape r = new Rectangle(4, 5);//System.out.printf(\"周长：%.2f, 面积：%.2f\\n\", c.girth(), c.area());System.out.printf(\"周长：%.2f, 面积：%.2f\\n\", r.girth(), r.area());//改造上面的代码：//理论准则：对象的编译时类型尽可能地写 父类Shape[] arr = new Shape[]{c, r};for(Shape s : arr) { System.out.printf(\"周长：%.2f, 面积：%.2f\\n\", s.girth(), s.area());} 面向父类编程 对象的编译时类型尽可能地写父类 方法的参数尽可能地写父类 方法的返回类型尽可能地写父类 编译时类型尽量写父类，好处就是可以以统一的标准来处理所有的子类对象。 那么，编译时类型是不是“越大越好”？ 当然不是，因为编译时类型决定了这个对象“所能看到见的行为”, 所以，编译时类型要恰到好处 编译时类型决定 了对象所能看到见的行为。 编译时类型是可变的。 运行时类型决定了对象在执行时的真正行为。 运行时类型是不可变的，它是在“出生”时就确定的 static 和 final 关键字 static 修饰方法 表示方法是静态方法，只能直接访问静态属性，不能直接访问非静态属性。 静态方法的调用是通过 类名.方法名 来调用的。 static 修饰属性 表示此属性是静态属性，也叫类变量，它是此类的所有对象/实例 共享的。 静态属性可以被静态方法直接访问。【同一个类中】 同样受访问控制修饰符的影响。 static 修饰代码块 表示静态代码块，它是在类加载时发生调用，而且只调用一次。【不是在创建对象时调用】 有关 final关键字，同样可以修饰如下的成员： final修饰类 表示此类是一个最终类，不能被继承 final修饰方法 表示此方法是一个最终方法，不能被子类重写[override] final修饰属性 表示此属性是一个常量属性，常量属性要求在构造方法中初始化或直接初始化。 final修饰局部变量 表示常量 作业 封装如下类型 员工类[Employee]，拥有姓名、手机号、基本工资 3个属性，并提供获取月薪的方法[getMonthSalary] 设计一个小时工类，他的基本工资为0， 拥有 每月工作小时数，每小时费用 2个属性，并重写 父类的 getMonthSalary方法 设计一个销售员工类，拥有 提成率和月销售额 2个属性，并重写父类的 getMonthSalary方法 设计一个固定工资的员工，无其它属性 为了达到面向父类编程的目的，请开发出 EmployeeUtil工具类，提供创建员工的静态方法以及根据员工来获取当月工资的方法。 再开发一个调用者类[UseEmployee]，以数组的方式存放创建好的员工【要求每种员工对象都要有一个】，并打印输出当月的工资。","link":"/2019/09/19/javase/%E7%BB%A7%E6%89%BF%20%E5%92%8C%20%E5%A4%9A%E6%80%81/"},{"title":"集合框架 JCF","text":"Java Collection Framework, 它是由一组API组成，主要是针对容器的封装，底层有不同的实现，比如：有基于数组的实现，也有链表、哈希算法、二叉树的实现。 在JAVA中，数据的容器有两种 基于值的存储， 有：List, Set 基于键、值对的存储, 有 Map 基于值的存储123456789java.util.Collection \\- List 有序、可排序、可重复 \\- ArrayList 基于数组的实现 \\- LinkedList 基于链表的实现 \\- Vector 同ArrayList, 它是多线程安全的，它的所有方法都是同步方法 \\- set 无序、不可排序，不可重复 \\- HashSet 使用哈希算法实现的 \\- SortedSet 是Set的一子接口，它是可排序的，当然，也不能重复 \\- TreeSet 使用二叉树实现的。 注:由于在JAVA中，数组容器在操作上有诸多不便，所以，API提供了JCF供我们使用。如此多的类型，它们各自的特点是不同的。 针对 List 来说，它的特点是元素有序、可排序，而且可重复，提供了基于数组和双向链表的两种不同的实现，我们在选择时，可以根据实际的情况进行选择。 Iterable 接口 Iterator iterator() ; 返回当前集合的迭代器 Collection的操作方法 boolean add(T element) 往容器中添加一个新元素 boolean addAll(Collection allElement) 往容器中添加指定容器中的所有元素 boolean remove(T element) 从容器中移除指定的对象 boolean removeAll(Collection elements) 从当前集合中删除指定集合中的所有元素 void clear() 清空容器 boolean contains(T element) 判断当前容器是否包含指定的元素 boolean containsAll(Collection elements) int size(); 获取当前集合有效元素的个数 toArray(); 把集合转换成数组 Iterator iterator(); 返回指向当前集合的迭代器 Iterator 接口 boolean hasNext() 判断迭代器中是否有下一个可使用的元素 T next() 取出迭代器指向的元素，并把指针向下移动一次。 List 【有序、不可重复】 T get(int index) 根据下标来访问元素 void set(int index, T element) 把元素Element放到指定的位置 List subList(int start, int end) 求子集，含start位置，不含end位置, 返回的是新的集合 boolean isEmpty() ; List的实现类 ArrayList public ArrayList() public ArrayList(int size); public ArrayList(Collection c) LinkedList public LinkedList(); public LinkedList(Collection c) 栈的特点 Stack 先进后出，FILO[First In, Last Out], 一般只提供针对栈顶的操作，包含：进栈，出栈，判断栈是否为空，以及栈中的元素个数 队列的特点 Queue 先进先出， First In, First Out[ FIFO ], 一般提从队头的操作【增、删、查】, 包含入队、出列操作 在JCF的API中，有提供这个接口。 12java.util.Queue [接口] \\- java.util.Deque 【接口】 它的方法主要有如下6个，集中在3个功能上，如下 ： 添加操作 add(E element) 如果队列容量不够，抛出异常 offer(E element) 如果队列容量不够，则执行失败返回false 删除操作 remove() 如果队列为空，则抛出异常 poll() 如果队列为空，则返回null 查询操作 element() 如果队列为空，则抛出异常 peek() 如果队列为空，则返回null Deque double end Queue, 简称 Deque， 它支持两端进行操作。它是 Queue的子接口。 同样，由于它是双端的操作，所以，它的核心方法比 Queue多一倍，也是集中在3个功能。 添加操作、删除操作、查询操作 Collection集合的结构类图123456789101112131415java.lang.Iterable \\- java.util.Collection \\- java.util.List \\- ArrayList \\- Vector \\- LinkedList \\- java.util.Set \\- HashSet \\- java.util.SortedSet \\- TreeSet \\- java.util.Queue \\- PriorityQueue \\- java.util.Deque \\- ArrayDeque//注： 以上带包的都是 接口，不带包的都是 实现类 Set 操作 几乎与Collection一样。 它的特点是：无序、不可重复 实现类：HashSet 它是如何做到 无序以及不可重复的呢？ 首先，当我们把一个对象添加到 HashSet时，这个容器会调用对象的 hashcode()方法，得到一个整数。根据这个整数来计算出此对象应该存放的位置。 其次，当我们再次添加一个对象时，同样会调用此对象的hashcode()方法，得到一个整数，算出它该存储的位置，此时，如果这个位置已经被占用了，则会调用它的 equals()方法，如果返回true, 说明此对象与之前的对象相等，则放弃存入。 如果返回false, 则表示对象不相等，则利用红黑树来存储进行纵向扩展。 注： 上面我们所讲的原理，其实是HashMap的原则，而HashSet中，只是组合了 HashMap，并且只是利用了它的 Key， 而Value永远是同 一个 Object. 作业 把上节课布置的模排诗改成竖排诗的作业利用集合重新来实现一下。 利用循环，随机生成10W个1-100之间的整数，请利用集合来统计出每个整数出现的次数","link":"/2019/09/19/javase/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"title":"io流","text":"IO流 是用来操作文件内容的。而文件的内容可以分成两个类别： 二进制文件，【所有除文本文件之外的文件，比如：音频、视频、图片、word, ppt, excel, …】 文本文件， 能够使用记事本打开的，使用者可以直接读懂的文件。比如：【.txt, .java, .md, …】 注： 不管二进制文件，还是文本文件，其本质都是010101的存储，不同在于它们的编码方式不同。 文本文件 是以字符集进行编码的，而字符集是由不同的国家和地区根据自己的情况制定的，并且得到国际上的认可。比如：中国地区的字符集编码就是 GBK, 西区地区的字符集是 ISO-8859-1, 国际编码字符集是 UTF-8， … 每个国家的字符集都是公开的 二进制文件 一般来讲，都是由软件厂商自己定义的编码规则，有的是公开的，有的是商业密秘，这些编码规则往往与创建此类格式的软件和解析此类格式软件形成一个闭环。比如：Word格式的文件，就必需使用 微软公司出品的Office办公软件去创建和解析。 注： 文本文件也是一种二进制文件，之所以把它单列出来，是因为它使用较为频繁，而且不方便使用二进制去处理它，而是使用字符去处理它更为方便。 所以，文本文件是以字符为单位进行处理的，在JAVA 的IO流包中，专门提供了一系列的API来处理文本文件，这类流叫字符流。 二进制文件是以字节为单位进行处理的，在JAVA的IO流包中，也专门提供了一系统的API来处理二进制文件，这类流叫字节流。 IO流的API 包: java.io 输入流和输出流 输入和输出都是以JVM为边界的，往JVM内存写入的，叫输入流。 反过来，从JVM内存中向外输出的，叫输出流。 输入 |||||||| ||||||| 输出 ——–&gt; ||||||||JVM内存 |||||||| ———–&gt; 字节流 有负责读取的输入流和负责写入的输出流 字节输入流1234567891011java.io.InputStream --- 抽象父类 \\- java.io.FileInputStream \\- java.io.ByteArrayInputStream \\- java.io.FilterInputStream \\- java.io.BufferInputStream \\- java.io.DataInputStream \\- java.io.PushBackInputStream \\- java.io.ObjectInputStream抽象出一些共性的接口java.io.DataInput \\- java.io.ObjectInput InputStream中的共性方法: int read() –&gt; 读取1个字节， 效率较低。 返回值 -1表示读到了文件尾[EOF], 非-1的返回值 表示读到的字节本身。 int read(byte[] buf) —&gt; 尝试最多读取 buf.length个字节，这个方法的返回值表示实际读到的字节个数。如果读到文件尾【EOF】，则返回-1 int read(byte[] buf, int offset, int length) —&gt; 从offset位置处开始尝试最多读取 length个字节，返回值的意义同第2个方法。 void close() –&gt; 释放流源释。 available() 字节输出流123456789java.io.OutputStream ---- 抽象父类 \\- java.io.FileOutputStream \\- java.io.BufferedOutputStream \\- java.io.DataOutputStream \\- java.io.ObjectOutputStream \\- java.io.ByteArrayOutputStream抽象出一些共性的接口java.io.DataOutput \\- java.io.ObjectOutput OutputStream中的共性方法： void write(int byte); 写入单个字节 void write(byte[] buf); 写入 buf.length个字节 void write(byte[] buf, int offset, int length) ; 写入 length个字节 void close() 以上这些流又可以分成两种，一种是本身具备流的读写能力的，一种是在原有流的基础上，添加新的功能的流。 节点流 就是本身拥有流的读写能力，比如：FileInputStream / FileOutputStream, ByteArrayInputStream/ByteArrayOutputStream 从构造器的参数也可以看出，这类流的构造是以”源” 为参数的。 过滤流 本身并没有流的读写能力，它必需借助于节点流来构造。比如：DataInputStream/DataOutputStream, BuffredInputStream/BufferedOutputStream, … 从构造器的参数也可以看出，这类流的构造是以 “流” 来参数。 这是一种装饰模式，我们来看一下各自的创建过程： 12345678910//节点流的创建FileInputStream fis = new FileInputStream(\"sample.md\");//过滤流的创建BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"sample.md\"));//假设我要构造一个带缓存，能读基本数据类型的流DataInputStream dis = new DataInputStream( new BufferedInputStream( new FileInputStream(\"id.dat\"))); 基本类型读写的流：-》 DataInputStream/DataOutputStream 利用此类型我可以把基本数据类型持久化到文件中 案例： 设计一个id从1开始依次增长的算法，要求即使程序退出后，下次再启动时，ID依然是增长的。 123456789101112131415public class 类名 { private long id; //... private static long index = 1L; public 类名() { this.id = generateId(); //... } private long generateId() { //利用IO流来持久化个值。 return index++; }} 思路： 首先，如果这个文件不存在，创建这个文件，并且把2L值写入到这个文件中。返回1L 如果文件存在，则先读取这个文件中的值，然后再把这个值+1，写回到这个文件中。 详见 IDGenerate.java 读写对象的流 -&gt; ObjectInputStream/ObjectOutputStream 这个可以进行对象的读写，要求对象的类型必需要实现 java.io.Serializable 接口 这个接口叫对象序列化接口，可以用来持久化对象的状态。 有关对象的读写操作，有两个细节需要注意： 被实持久化的对象必需要实现 java.io.Serialiable 接口 如果某些属性不想被持久化外，则使用transient 修饰符进行修饰。 随机读写流 RandomAccessFile 它是一个即支持读、也支持写的节点流, 它实现了 DataInput和DataOutput 接口。 它还支持移动访问的位置 常用方法 public RandomAccessFile(String path, String mode) public RandomAccessFile(File path, String mode) seek(long pos) getFilePointer() -&gt; long … 主要的打开模式有： “r” 以只读模式打开 “rw” 以读写模式打开 字符流 字符流是以字符为单位处理的流，它实际上是JVM针对字符文件所做的特殊处理。 本质上，有了字节流，就可以处理字符文件，但是，不方便。 字符输入流12345678java.io.Reader \\- FileReader \\- CharArrayReader \\- FilterReader \\- PushbackReader \\- BufferedReader [*] 带缓存，而且整行的读取 readLine() \\- InputStreamReader [字节流到字符流的桥接器] \\- .... Reader常用方法 read() 读取单个字符 read(char[] buf) 尝试读取buf.length个字符 read(char[] buf, int offset, int length) 尝试从偏移量offset 处 读取 length个字符 close() 释放 BufferedReader的方法 readLine() -&gt; String 此方法以换行符为终止符，但是，返回的字符串是不包含这个终止符。 字符输出流1234567java.io.Writer \\- FileWriter \\- CharArrayWriter \\- OutputStreamWriter [字节输出流到字符输出流的桥接器] \\- BufferedWriter \\- PrintWriter [*] 自带缓存，而且支持整行的写入, println() \\- ... Writer的常用方法： write(int c) 写入传入的单个字符 write(char[] buf) 把buf 中的字符写入到输出流，写入的是 buf.length个字符 write(char[] buf, int offset, int len) 同上,写入的是 len个字符 close() 有关字节流到字符流的桥接口 有些标准输入输出设备被定义成了 字节流，可是我们需要把它转换成字符流，这里就可以使用这个桥接器，如下： BufferedReader br = new BufferedReader(new FileReader(“hello.txt”)); //指向文本的字符输入流 再看： BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 再看，我有一个指向文本文件字节流, 并且重新指定字符集为 GBK BufferedReader br = new BufferedReader( ​ new InputStreamReader( ​ new FileInputStream(“hello.txt”), “GBK”)); InputStreamReader的构造器 InputStreamReader(InputStream in) 采用默认字符集做转换器 InputStreamReader(InputStream in, String charsetName) 指定的字符集做转换器","link":"/2019/09/19/javase/IO%E6%B5%81/"},{"title":"字符串","text":"它是使用较为频繁的类型，而且也是不可变对象。【同数字、和日期、时间】 所以，这些类型都是不可以被继承的。 相关的类型： java.lang.String java.lang.StringBuilder java.lang.StringBuffer java.lang.CharSequence java.util.regex.Pattern java.util.regex.Matcher 注：CharSequence 本质上是 char[] , 它的实现类中，就是组合了 char[]。 CharSequence 常用方法： charAt(int index) 返回指定位置处的字符 length() 返回字符序列中的有效字符个数 subsequence(int start, int end) 求子串 toString() 返回字符串表示形式，同样是副本。 JDK8之后，为了增加具体子类的功能，添加2个默认方法： chars() codePoints() String中的常用方法 indexOf() lastIndexOf() substring() replace() length() split() match() …. StringBuilder和StringBuffer 的常用方法 这两个类中的方法和实现都是一模一样的，唯一的不同点在于： StringBuilder 不是多线程安全的，是轻量级的。 StringBuffer 是多线程安全的，是重量级的，也就是它的所有方法都是同步的【加了互斥锁】 所以，在非多线程的情况下，建议选用 StringBuilder。 常用方法： append() 方法，这个作用相当于String的”+”运算符。就是把字符串追加到原来的字符序列中。 reverse() 方法，反转此容器的字符序列 并返回它的副本。 字符串的切割和组合 split() 方法， 用指定的分割符来切割字符串，它有如下2个重载 split(String regex); 此方法相当于调用了 split(regex, 0) 方法 split(String regex, int limit); 其中,limit 有三种值 当limit==0时，表示使用regex尽可能多的次数去切割原始字符串，并把尾部的空白结果给去掉 当limit&lt; 0时，表示使用regex尽可能多的次数去切割原始字符串，并保留尾部的空白结果。 当limit&gt;0时， 表示使用regex去匹配 limit-1 次。 join() 方法， JDK8 才加入的一个静态方法，方便我们组装字符串数组。 字符串和字节数组的转换 字符转换成字节叫 编码[encode] 字节转换成字符叫 解码[decode] 在字符进行编解码的过程中，都需要指定字符集/编码集，常用字符集有： UTF-8， 支持中文， 动态字节编码 ISO-8859-1 西欧字符集，不支持中文 GBK 国标码， 双字节编码 ASCII 码， 也不支持中文，单字节编码 相关的方法 把字符转换成字节的方法： getBytes() 采用平台的默认字符集来进行编码 getBytes(String charsetName) 采用指定的字符集进行编码，这个字符集的字符串要合规定。 把字节转换字符的方法： new String(byte[] arr); 以默认字符集来解码给定的字节数组 new String(byte[] arr, String charsetName); 以指定的字符集来编码给定的字节数组 乱码的由来 当你的编解码字符集选择不一样时，就会造成乱码。 正则表达式 【Regular Expression】 由字母、数字和一些特殊字符所组成的有特定含义的字符序列。 它的目的是用来去快速匹配目标字符序列的。 在JDK1.4引入了对正则表达式的支持。 java.util.regex包 Pattern 类 Matcher 类 1234567891011121314151617181920212223String str = \"hello world\";//如果要判断这个字符串是否包含字符序列 orif(str.indexOf(\"or\") &gt;= 0) { //说明这个字符串中是存在 字符序列or 的 //...}或if(str.contains(\"or\")) { //说明这个字符串中是存在 字符序列 or的 //...}以上的判断都是基于精准匹配的，再看如下的代码String content = \"yjf210000@163.com\";//如何去判断这个字符串是否包含一个 “有效的” 邮箱地址？//这是一种基于 “模式\"的判断，不是一个具体的字符序列的判断//这种判断，上面的方法是做不到的，这里就可以使用 正则表达式 来完成判断。//因为正则表达式就是一种基于模式的判断, 模式就是规则。String regex = \"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$\"; //合法邮箱的规则//if(content.matches(regex)) { // 说明，这个字符串 content 是匹配模式 regex //...} 以上的例子中，这个 matches 方法只能做一次性的匹配，不能做搜索 也不能去把匹配的字符序列给 单独找出来。 如果要完成以上2点，则需要使用 Pattern 和 Matcher Pattern类型是 正则表达式/模式 载体，它负责解析这个模式。 Matcher类型是 存储匹配的结果的。 实际上，String.matches(regex) 方法，等价于： 123456789101112String content = \"yjf210000@163.com\";String regex = \"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$\";//Pattern p = Pattern.compile(regex);Matcher m = p.matcher(content); if(m.matches()) { //....}//与 String中的matches方法等价if(content.matches(regex)) { // ...} 正则表达式的规则 详见API文档 异常 是一种特殊的类型，分成2类 异常 Exception 错误 Error 这两种都被定义可抛出的类型，所以，JDK中提供了一个父类：Throwable java.lang.Throwable ​ \\- java.lang.Error 一种比较严重的错误 ​ \\- java.lang.Exception 异常是一种JAVA程序的信号传递机制。它可以通过属性封装更多的信息量。 首先，我们来看一下父类 Throwable的构造方法和常用方法 public Throwable() public Throwable(String message) public Throwable(String message, Throwable cause) getMessage() getCause() printStackTrace(); 打印异常的堆栈信息 再来看看子类 Exception 中的方法 完全继承于 Throwable ，没有自定义任何的个性化方法。 JAVA中处理异常的语法消极的处理方法 就是利用 throw 关键字把异常向上抛出【抛给上一级调用者】 如果这类异常需要在方法层面上进行申明，则利用 throws 在方法层面申请即可，语法如下： 123修饰符 返回类型 方法名(参数列表) throws 申明的异常类型列表 { //...} 注：多个异常类型之间使用 逗号 隔开。 积极的处理方法 利用 try catch finally 块来处理异常，语法如下: 1234567891011121314try { //把有可能出现异常的代码块放入其中 //... //...} catch (异常类型 | 异常类型 | 异常类型 e ) { //处理异常的代码 //...} catch (异常类型 e) { //... } finally { //不管try 块中的代码是否出现的异常，此处的代码是一定会被执行的。 //...} 注： 如果你打算针对不同的异常类型做不一样的处理，则建议分开写多个 catch 块。 如果你的异常处理逻辑是一样的，则合在一起写。 注： 如果有多个catch块时，应该把父异常的 catch 块写在后面。 这个异常处理的代码结构有多种变种，如下： try catch 变种 1234567try { //...} catch (异常类型1 e) { //..} catch (异常类型2 e) { //..} try finally 变种 123456try { //.... } finally { //...} 异常的层次结构1234567891011121314151617181920java.lang.Exception \\- RuntimeException 运行时异常，在JVM内部发生的异常，也就是没有超出JVM的边界。 \\- NullPointerException \\- ArrayIndexOutOfBoundsException \\- TypeMismatchException \\- ClassCastException \\- IllegalStateException \\- NoSuchElementException \\- ArithmeticException \\- .... \\- 非运行时异常 【除RuntimeException分支之外的异常】，超出了JVM的边界的。 \\- InterruptedException \\- FileNotFoundException \\- IOException \\- SQLException \\- SocketException \\- BindException \\- UnsupportedEncodingException \\- ... 注： 针对运行时异常[RuntimeException] ,JVM 不强制程序员去处理，也就是说，我们不处理这种异常，JVM也不会去检查，也就不会出现编译错误。针对此类异常，JVM希望程序员要编码谨慎，多做判断，以此来尽可能地避免此类异常的发生。 如果是非运行时异常，则JVM会强制要求程序员去处理，那么程序员有2个选择 直接在方法层面申明抛出 【消极的处理】 利用try catch 去捕获取并处理 【积极的处理】","link":"/2019/09/19/javase/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99/"},{"title":"抽象类和接口","text":"抽象类是指用 abstract 修饰符来修饰的类型。 接口是一种特殊的类型，使用 interface 来定义，它是完成抽象的类型。 在JAVA中，抽象类和接口 都属于 ADT ，也就是 抽象数据类型。 static和final static 修饰方法 表示方法是静态方法，只能直接访问静态属性，不能直接访问非静态属性。 静态方法的调用是通过 类名.方法名 来调用的。 static 修饰属性 表示此属性是静态属性，也叫类变量，它是此类的所有对象/实例 共享的。 静态属性可以被静态方法直接访问。【同一个类中】 同样受访问控制修饰符的影响。 static 修饰代码块 表示静态代码块，它是在类加载时发生调用，而且只调用一次。【不是在创建对象时调用】 注： 类加载[classload] 发生在JVM加载目标字节码时。 静态代码块有应用中有什么作用？ 由于它是发生在类加载时机，而且只执行1次，所以，适合用来做不变资源的初始化操作，比如：配置性文件的加载、连接池初始化、等。 如果一个类中，有静态的属性或静态的代码块，则在此类被JVM加载时，就会执行： 给静态属性申请堆空间 给静态属性赋默认值 调用静态代码块 我们再来看看对象创建的过程： 总是按如下3步，递归地创建父类对象： 给普通属性申请堆空间 给普通属性赋默认值 调用构造方法【如果有普通代码块的话，则会先调用普通代码块】 正是因为静态的成员和普通的成员执行的时间是不一样的，所以： 静态方法不提直接访问非静态成员。反过来，普通方法可以直接访问静态成员。 如果你一定要在静态方法中去访问非静态的成员，则需要实例化对象，然后通过对象去访问非静态成员。 思考？为什么main方法一定是静态的？ 因为JVM最早加载的类型是拥有main方法类型【程序的入口】，我们业务代码都必需从 main 方法开始。如果main方法不是static的，则JVM就不能直接去调用它，必需通过对象才能调用，可以，创建对象的代码是写在main方法中。所以，main方法必须是static，才能满足JVM的规范要求。 static的应用 可以用来做一个内部的计数器，统计此类的实例创建的个数。 单例模式的应用 是指某个类型，在整个应用的生命周期中，最多只有一个实例存在。 我们如何去保证某个类的实例是唯一的呢？ 我们知道类的实例，是需要调用 构造器 的。所以，为了不让外界自由地调用构造器，我们需要把构造器的访问控制修饰符设为 private 提供一个唯一的对外方法，返回一个实例。 提供一个静态属性，指向唯一的实例，这个实例的创建有2个时机，分别是： 饿汉式，也就是在属性中直接初始化 懒汉式，当用户调用获取唯一性实例方法的时候进行判断，如果实例没有被初始化，则进行初始化，并返回。如果实例已经初始化了，则直接返回。 有关 final关键字，同样可以修饰如下的成员： final修饰类 表示此类是一个最终类，不能被继承 final修饰方法 表示此方法是一个最终方法，不能被子类重写[override] final修饰属性 表示此属性是一个常量属性，常量属性要求在构造方法中初始化或直接初始化。 final修饰局部变量 表示常量 注：常量属性往往都写成 static ,因为常用属性的值是不可变的，所以，没有必要每个对象实例都拥有一份，大家可以共享一份。 所以，常量属性都会写成 public static final 数据类型 属性名 常量属性的初始化 直接初始化 【*****】 在静态代码块中初始化【属性要加 static】 在构造方法中初始化 抽象类语法： 12345pubic abstract class 类名 { //属性 //方法} 抽象类的特点 抽象类不能被实例化。 抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类 抽象类的意义在于它会被子类继承，所以，抽象类一定不能使用 final 修饰符。另外，基于类似的原因，abstract修饰符也不能写private修饰符一起使用。 抽象方法 没有方法体的方法，直接以;结束，并且在修饰符中使用 abstract 修饰符 如： 1public abstract void ma(); 什么样的类应该设计成抽象类呢？ 理论上来说，父类/超类都可以考虑设计成抽象的父类. 如果父类中的业务方法，没有办法实现时，那此父类就一定要设计成抽象的。 案例： 1234567891011121314151617public class Shape { // public double girth(){ return 0.0; } public double area() { return 0.0; }}这个类型可以改造成抽象类，如下：public abstract class Shape { // public abstract double girth(); public abstract double area();} 我怎么知道，我要写抽象类呢？ 当我们写完具体的业务时，应该停下来考虑一下，我们是否要提出一个更高层次的类型，以为将来的扩展做好准备。 我们来看看API中，Calendar类及其子类的设计 1234//1.Calendar c = new GregorianCalendar();//或Calendar c = Calendar.getInstance(); 使用下面的方式来创建日历对象比你直接使用 new 要好得多，比如：在若干年以后，JDK中收录了另一个实现类，叫XXXCalendar子类。 那么，使用下面代码来创建日历对象的程序，直接升级JDK后，就可以使用新的日历，而使用上面代码创建日历的程序就必须要重新改写。 1234567891011121314151617181920212223242526272829303132333435363738//JDK8.0版本中的实现public abstract class Calendar { .... public static Calendar getInstance() { // return new GregorianCalendar(); }}public class GregorianCalendar extends Calendar { ... ...}若干年以后，出现了一个叫 XXXCalendar的子类，被收录到JDK15版本中//JDK15public abstract class Calendar { .... //优化下面的代码，要前向兼容之前的实现，同时，也可让JDK15版本的使用能够使用新的日 历 public static Calendar getInstance() { //获取JDK的版本号 int version = xxx; if(version &lt; 15) { return new GregorianCalendar(); } else { return new XXXCalendar(); } }}public class GregorianCalendar extends Calendar { ... ...}//JDK15中加入的public class XXXCalendar extends Calendar { ... ...} 接口 定义： 12345public interface 接口名 { //属性 //方法} 注： 接口是一种特殊的类型，它有如下的特点 是可以多重继承的，一个接口可以继承多个接口 一个类可以实现[implements]多个接口。 接口的所有属性都是公开静态常量，也就是默认就是 public static final 修饰 接口的方法都是公开抽象方法，也就是默认使用public abstract 修饰。从JDK8开始，接口中可以定义 static方法和default方法，有关 default方法和static方法后面再说。 例： 123456public interface IA { int ROW = 5; int COL = 9; // void ma();} 如果我们的类要实现这个接口，使用implements 关键字。如下： 12345678public class IAImpl implements IA { @Override public void ma() { //.... //... }} 注：一个类实现了1个或多个接口后，要实现这些接口中的所有抽象方法，除非这个类是一个抽象类。 接口之间同样可以继承，如下： 1234567891011121314151617181920212223242526272829303132public interface IB { // void mb();}public interface IC extends IA,IB { // void mc();}public interface Writable { // void write();}//如果某个类实现了IC接口，则这个类必需要实现IA, IB, IC 三个接口中的所有抽象方法，除非这个类是抽象的。public class ICImpl implements IC, Writable { @Override public void ma() {} @Override public void mb() {} @Override public void mc() {} @Override public void write() {}}//调用者代码：IA a = new ICImpl(); //okIB b = new ICImpl(); //okIC c = new ICImpl(); //okWritable d = new ICImpl(); //ok 开发中的接口命名规则 以字母I 开头 以字母 able 结尾 接口定义的原则 功能尽可能地单一。 在面向对象的编程思想中，有一条原则叫接口隔离原则，讲得就是接口的功能要互相隔离，不要把过多的功能集中在单一接口中，这样会造成接口的污染。 接口的类型根据每个接口中的成员不同，可以分成三种类型： 普通接口 常量接口，只有属性，没有方法的接口，在JDK5之后，这种类型往往会被枚举代替。 标记接口，即没有属性，也没有方法的接口。如：java.lang.Cloneable 接口 如： 12345678910111213141516171819202122232425262728293031public interface Haha { //nothing!}public interface Readable { void read();}//public class A implements Readable { @Override public void read() { ... }}public class B implements Readable,Haha { @Override public void read() { ... }}public class C implements Readable,Haha { @Override public void read() { ... }}//调用者：public static void main(String[] args) { //... Readable[] arr = new Readable[]{new A(), new B(), new C()}; for(Readable r : arr) { r.read(); //针对B和C，我要做一些额外的操作 if(r instanceof Haha) { .... } }} 面向接口编程 同前面讲过的面向父类编程思路一样，这里以Hello.java为例。 1.直接写实现类 12345public class Hello { public static void main(String[] args) { System.out.println(\"hello,world\"); }} 演进一下 12345678910111213public class Hello { public void sayHi() { System.out.println(\"hello,world\"); }}//再开发一个调用者public class UseHello { public static void main(String[] args) { //创建对象 Hello h = new Hello(); h.sayHi(); }} 再演进一下 123456789101112131415161718public interface IHello { void sayHi();}// 实现类public class Hello implements IHello { @Override public void sayHi() { System.out.println(\"hello,world\"); }}//再开发一个调用者public class UseHello { public static void main(String[] args) { //创建对象 IHello h = new Hello(); h.sayHi(); }} 再次演进 1234567891011121314151617181920212223242526272829public interface IHello { void sayHi();}// 实现类public class Hello implements IHello { @Override public void sayHi() { System.out.println(\"hello,world\"); }}//再次实现一个更复杂的 sayHi的方法public class ComplexHello implements IHello { private int count; public ComplexHello(int count) { this.count = count; } @Override public void sayHi() { for(int i=0;i&lt;this.count;i++) { System.out.println(\"hello,world\"); } }}//再开发一个调用者public class UseHello { public static void main(String[] args) { //创建对象 IHello h = new ComplexHello(5); h.sayHi(); }} 为了让调用者不再面向具体的子类编程，我们还可以提供一个工厂类 再来演进 123456789101112131415161718192021222324252627282930313233343536373839public interface IHello { void sayHi();}// 实现类public class Hello implements IHello { @Override public void sayHi() { System.out.println(\"hello,world\"); }}//再次实现一个更复杂的 sayHi的方法public class ComplexHello implements IHello { private int count; public ComplexHello(int count) { this.count = count; } @Override public void sayHi() { for(int i=0;i&lt;this.count;i++) { System.out.println(\"hello,world\"); } }}//再开发一个工厂类public class HelloFactory { public static final int HELLO = 1; public static final int COMPLEX_HELLO = 2; public static Hello createHello(int type,int... args) { //根据类型 type，来决定创建哪个具体的实例对象 ... }}//再开发一个调用者public class UseHello { public static void main(String[] args) { //创建对象 IHello h = HelloFactory.createHello(HelloFactory.COMPLEXT_HELLO, 5); h.sayHi(); }} 进过上面的演进，整个代码结果就可以做到 对扩展开放，对修改关闭, 也就是方法和类的申明不再变化，而只是实现进行扩展。 JDK8中的接口新规范 接口中可以使用 default 关键字来定义实现的方法. 接口中也可以使用static关键字来定义实现的静态方法,这种方法，实现者不能继承，只能通过接口名.静态方法来访问。 备注 静态方法是没有多态性的，就是指父类的静态方法即使被子类重写了，也不会有多态性。 抽象方法不能是静态的，也就是说，abstract和static关键字不能同时修饰方法.","link":"/2019/09/19/javase/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"},{"title":"抽象类和接口的总结","text":"两者的异同*不同点: * 抽象类只能是单继承，而接口是支持多继承的 抽象类是部份抽象的，而接口是完全抽象的【JDK8之前】 相同点: 都是ADT 都不能被实例化 都是做为父类存在，或者说是编译时类型。它们一起构成系统的“抽象层” 针对抽象类的应用场合 首先，类之间要满足 “IS A” 的关系 多个子类要存在共性。 针对接口的应用场合 在任何时候，只要考虑到扩展性、伸缩性，都应该使用接口 接口就是规范，有规范的地方，就是接口 接口非常的灵活，尤其是JDK8之后，可以使用 default 关键字来给子类添加新功能。 简单工厂模式、模板模式、回调模式工厂模式 简单工厂 目的就是用来创建某一类对象/实例. 实现的思路： 提供一个公开、静态方法，返回目标类型的实例 工厂方法可以重载 123456789101112131415161718192021222324252627282930313233//定义一个父类或接口public interface IA { void ma();}//定义实现类public class IAImpl_1 implements IA { // .... @Override public void ma() { ... }}//也许还有其它的实现类// ...//提供一个工厂来创建IA的实例public class IAFactory { // public static IA getInstance(参数要根据实际的情况来设计) { //算法 ... return new IAImpl_1(); }} //调用者：public static void main(String[] args) { //通过工厂来获取实例 IA a = IAFactory.getInstance(....); // a.ma();} 抽象工厂/复杂工厂 模板模式【template】 模板方法的适用场景： 有固定的执行流程/步骤, 其中有些步骤的实现需要子类来完成【父类完成不了】，这种情况下，我们就可以制定模板方法。 注：模板方法本身不是抽象的，而且应该使用 final 修饰符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//假设如下场景，把小品的表演业务分成4个流程，其中，第一和第四个流程是在父类中实现的，第二和第三个流程是由子类完成的public abstract class 小品 { //这是一个模板方法 public final void action() { //报幕方法 报幕(); //... 叙事(); //... 抖包袱(); //... 煽情(); //... 结尾(); } // public void 报幕() { //也许在父类中有能力去实现这个方法 ... } public void 叙事() { //... } //针对不能实现的方法，就定义抽象的方法 public abstract void 抖包袱(); // public abstract void 煽情(); // public void 结尾() { //可以实现 }}//子类public class 不差钱 extends 小品 { //属性 private String[] actors; //... public void 抖包袱() { //... } // public void 煽情() { //... }}//调用者public static void main(String[] args) { // 小品 a = new 不差钱(); a.action();} 回调模式【Callback】 往往都与模板配合使用。它是指当某个方法的实现需要依赖于调用者提供的局部实现时，此时，我们可以让调用者传入“这个局部的实现”，这个“局部的实现”就可以抽象为 接口类型 如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//定义回调接口public interface 可抖包袱的 { void 抖包袱();}// public interface 可煽情的 { void 煽情();}//public class 小品 { //这是一个模板方法 public final void action(可抖包袱的 d, 可煽情的 s) { //报幕方法 报幕(); //... 叙事(); //... d.抖包袱(); //回调，回调用户传给我的接口中的方法 //... s.煽情(); //回调，回调用户传给我们的接口中的方法 //... 结尾(); } // public void 报幕() { //也许在父类中有能力去实现这个方法 ... } public void 叙事() { //... } // public void 结尾() { //可以实现 }}//子类public class 不差钱 extends 小品 { //属性 private String[] actors; //... public void 抖包袱() { //... } // public void 煽情() { //... }}//调用者public static void main(String[] args) { // 小品 a = new 不差钱(); a.action(new 可抖包袱的实现者(), new A());}//可煽情的 接口实现者public class A implements 可煽情的 { //.... @Override public void 煽情() { //... }} 注:如果方法的参数是接口的话，则在此方法内部一定会进行回调 案例 Object类和基本类型的包装类 Object 类是JAVA所有类型直接或间接的超类。 它里面的公开以及protected 方法是所有JAVA对象都可以访问/使用的. 常用的有： toString 方法, 它的本意是把对象以字符串的形式描出来并返回，主要是属性。可是，Object中是没有办法做到这一点的，因为它永远不知道有哪些类继承了它，所以，它采用的策略是提供一个默认的简单实现【返回此对象的16进制的内存地位】，并建议子类 去重写这个方法 equals 方法，用来判断两个对象是否相等。此方法的默认实现就是比对象的内存地址。所以，我们的类也应该重写此方法，以从逻辑层面来定义对象是否相等。 hashcode 方法，默认是以内存地址来计算的。 clone 方法，克隆对象，它的要求是：目标类型必需要实现 java.lang.Cloneable 标记接口。 finalize 方法，本意是在GC收回对象之前，会回调对象的finalize方法，这样一来，我们程序员就可以利用这些次机会，在此方法中做一善后处理的工作。但是，由于GC的运行时机，程序员是不能控制的，所以，我们没有办法确定此方法的执行时间，所以，不建议使用。 getClass 方法，用来获取对象的运行时类型，返回类型是：Class 编写equals和hashCode方法的要求： 如果你使用 Eclipse IDE来生成的话，则无视这个要求，因为它是满足的。 如果你要手写这两个方法的实现，请遵守如下规则： 所有在equals方法考虑的属性，也必需出现在 hashCode方法中。 因为hashCode的算法要求： 如果对象的equals方法返回true, 则他们的hashCode值必需一样。 如果对象的equals方法返回false, 则尽最大努力保证它们的hashCode值不一样。 要实现对象的克隆，有如下要求： 重写Object类的 clone方法，把访问控制修饰符上升到 public 实现 java.lang.Cloneable 标记接口 注：Object类中clone的默认实现只 能做到 浅拷贝。如果想实现深拷贝，只需要重新实现 clone 方法。 getClass方法: 用来获取对象的运行时类型。 同一个类型加载进JVM后，不管它创建了多少个实例，它的 Class 实例在JVM只有1个。 我们可以通过如下3种方式来获取这个 Class的实例 obj.getClass() Object.class Class.forName(“java.lang.Object”); finalize 方法 作业 设计一个客户类[Customer]，包含如下属性：id, 客户名，客户电话，客户等级 ，生成构造、getter/setter、hashcode和equals以及toString方法 设计一个订单类[Order]， 包含如下属性：id, 订单编号【内部生成，规则另定】，订单费用，下单时间，出货时间，订单状态，所属客户[Customer],同样生成 构造、getter/setter、hashCode和equals方法，以及toString方法。注：在toString方法中不要出现customer属性 订单生成规则如下： 由年月日时分秒+4位数字组成，这4位数组从0001开始编号，一直到9999， 1秒内不能超过9999个订单。 在同一个秒内，这4位数字依次递增，不能重复，到下一秒时，重新从0001开始编号。【算法请自行实现】 写一个测试类，循环生成1000个订单，并输出这1000个订单的编号。 三大类型的操作数字型日期型字符串","link":"/2019/09/19/javase/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%80%BB%E7%BB%93%E3%80%81%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%E3%80%81Object%E7%B1%BB/"},{"title":"数组操作","text":"字符的表达方式普通字符表达 使用单引号括起来即可，如： char c1 = ‘A’; char c2 = ‘我’; 特殊字符 经过转义符转义后的字符形式，它的语法：\\字母 转义符是: \\ 如: char c1 = ‘\\t’; 常用的特殊字符有: 字符 描述 \\t 制表符 \\n 换行符 \\r 回车符 \\\\ \\ ' ‘ \\&quot; “ … … unicode 字符表示法 是一种全球统一的的编码标准，它涵盖了所有国家和地区的字符，为每个字符都编了唯一的二进制码。 它的语法如下： \\u4位十六进制表示法 如： char c = ‘我’; 还可以： char c1 = ‘\\u6211’; 在JDK中，提供了一个命令 native2ascii用来把任意的字符转换成 unicode 字符。 一维数组【array】 数据存储的最基本的容器[container],可以集中管理和维护数据。 语法: 123456789101112数据类型[] 数组名; 或数据类型 数组名[]; // 数组的申明、定义如：int[] iarr;//再来看看初始化数据类型[] 数组名 = new 数据类型[length];//注：这个 length 代表数组在初始化时，规定的元素个数，它是不可以变的。初始化数组时，必需要指定长度。 注意点: 数组本身也是一种变量，它是对象类型的变量【简称对象】 数组类型是一种对象类型，不是基本类型。 数组的初始化一定是使用 new 运算符。 注：数组是对象类型，数组元素可以是任意类型 数组的概念 数组一旦初始化，长度不可变 数组的所有元素共享同一个数组名，不同元素之间使用数组名[下标] 来访问 下标的长度从0至length-1 数组名存放的实际上是指向堆空间中数组第一个元素的地址。 数组元素的默认值不同类型的数组元素，其默认值是不一样的。如： byte, short, int,long 数组元素的默认值是0和0L char 数组元素的默认值是 \\u0000 boolean 数组元素的默认值是 false double和float数组元素的默认值是 0.0 对象类型数组元素的默认值是 null 例:1int[] iarr = new int[10]; //初始化一个长度为10的整型数组，这个数组中的每个元素的默认值是 0 数组元素赋值 单个赋值 通过循环来赋值【得到规律】 在初始化时直接赋值 123456789101112131415语法：数据类型[] 数组名 = new 数据类型[]{ 元素值1，元素值2，...,元素值N};注：此种情况下，[]里面不能规定长度。如：int[] jarr = new int[] {1,3,5,7,13,45,21,78,90};还可以简写：int[] jarr = {1,3,5,7,13,45,21,78,90};//简写的方式要求要在定义时直接初始化，不能先定义，后再初始化int[] karr;karr = {1,3,5,7,13,45,21,78,90}; //error//这种情况下，就必需使用 new karr = new int[] {1,3,5,7,13,45,21,78,90}; //ok 数组元素操作 数组做为数据的容器，我们需要对这些数据进行增、删、改、查的操作，简称 CRUD 操作 查询元素 从前面或后面开始循环迭代数组，依次与目标元素进行比对，如果找到，则记录下元素的下标位置。找出数组中，最大或最小的元素 123456789101112//1. 假设第1个元素是最小的int[] arr = ...;int min = arr[0];//for(int i = 1; i &lt; arr.length; i++) { //比较 if(arr[i] &lt; min) { min = arr[i]; }}//System.out.printf(\"最小元素是：%d\\n\", min); 元素的排序 根据规则，对元素的顺序进行重新调整。以满足业务要求。 一般都是分为 升序和降序 两种。 排序算法也很多，常用的有： 冒泡排序算法 选择排序算法 插入排序算法 快速排序算法 API中提供的数组工具类 java.util.Arrays 类 常用的方法 binarySearch — 采用二分法搜索目标元素，找到则返回下标，找不到则返回负数 sort — 排序方法 copyOf – 用来拷贝数组元素并返回一个全新的数组 toString – 以字符串的形式返回数组中的所有元素，以[element1, element2, …., elementN] 格式呈现 … …. 元素的插入和删除 注意点： 数组的长度在初始化结束后就不可以再变。所以，当我们删除数组中的某个元素时，仅仅把被删除元素后面的元素移次往前移是不够的，因为这样一来，原始数组的长度并没有变化。所以，我们只能重新创建一个新的数组，长度为原始数组的长度-1， 再把原来数组中没有删除的元素COPY到新数组中，并把新数组的地址赋值给原数组名。 二维数组 java语言是支持多维数组的，也就是数组的元素本身也是数组。 因为数组的元素可以是任意类型，而数组是对象类型，所以，数组的元素可以是数组。 所以，二维数组的本质就是它的每个元素又是一维数组。 语法： 12345678数据类型[][] 数组名;初始化：数据类型[][] 数组名 = new 数据类型[row][col];注：row 是指二维数组的长度，在初始化时必需要指定的col 是指一维数组的长度，也就是二维数组中每一个元素的长度。 这个值如果不指定，可以在事后初始化。 例： 12int[][] arr = new int[5][3];//二维数组 arr的长度是 5，它的每一个元素都是长度为3的一维数组。 二维数组的定义语法123456789101112131415161718192021222324252627282930数据类据[][] 数组名字 = new 数据类型[row][col];注：row 指的是二维数组的长度，在初始化时必需要指定col 指的是二维数组中的元素【一维数组】的长度，可以事后再初始化。所以，我们在初始化二维数组时有如下两种方式：//1. 在初始化二维数组时，直接把它的元素【一维数组】也给初始化了int[][] arr1 = new int[5][3];//此时，这个二维数组中的所有元素值都是 0， 迭代方式如下：//for(int i = 0;i &lt; arr1.length; i++) { //迭代二维数组 //取出它里面的每一个元素【一维数组】 for(int j = 0; j &lt; arr1[i].length; j++) { //迭代 一维数组 System.out.printf(\"arr1[%d][%d]=%d \", i, j, arr1[i][j]); } System.out.println();}//2. 在初始化二维数组时，只给定row,而col不指定，这样一来，我们就需要在循环中，再次去初始化这个二维数组中的每一个元素【一维数组】如：int[][] arr2 = new int[5][];//此时，arr2 是已经初始化了，但是，arr2[0],arr2[1], ... arr2[4] 都没有被初始化。for(int i = 0;i &lt; arr2.length; i++) { //此处，我们要初始化这个二维数组中的每一个元素 arr2[i] = new int[i+1]; //现在，可以迭代了 for(int j = 0; j &lt; arr2[i].length; j++) { System.out.printf(\"arr1[%d][%d]=%d \", i, j, arr1[i][j]); } System.out.println();} 练习:1.设计一个程序，根据用户输入的二维数组的长度，生成一个二维数组，并且以杨辉三角的值来填充这个二维数组，最后输出这个二维数组。 杨辉三角的规则： 它的任一行的第1列和最后1列的值都是1 除上面的规则外，其它行和列的值是当前所在列的上一行的同列和前一列 值之和。 方法 method 把相关的功能代码块抽取出来，形成一个可执行的业务单元，这个业务单元叫方法或函数。 在java中，方法有其内在的定义规范： 123修饰符 返回类型 方法名(参数列表) 可抛出的异常类型列表 { //方法体} 1. 修饰符 modifiers 访问控制修饰符 【3个，4种情况】 public 公开的、公共的，所有执行体都可以去调用的方法 protected 受保护的，同包和子类的执行体可以调用的方法 [默认] 只有同包的执行体可以调用的方法 private 私 有的，只有本类的其它执行体可以调用的方法 全体类 子类 同包 本类 public Y Y Y Y protected N Y Y Y 默认 N N Y Y private N N N Y 特殊修饰符 static 静态的，加了此修饰符的方法，可以直接通过 类名. 方法名 来调用， 所以，没有加此修饰符的方法，就只能通过 对象.方法名 来调用 abstract 抽象的，加了此修饰符的方法，是没有方法体的【也就是没有大括号】 final 最终的， 加了此修饰符的方法，不能被重写[overwrite] native 本地方法 default 默认方法，【JDK8.0之后，接口中可以定义默认方法】 … 一个方法的修饰符可以有多个，而且它们之间没有顺序。 如: 123public static void main(String[] args) {}或:static public void main(String[] args) {} 返回类型 它是指方法的“输出”， 把方法的执行结果给“带”出来。它可以分成两个大类 void 类型， 表示此方法没有返回类型，意味着在方法体中可以不写return语句。 非void 类型，也就 是任意合法的数据类型。表示此方法体中一定要写 return 语句,而且如果你有多个分支的话，每个分支都可以考虑 return语句。 注：当我们在设计方法的时候，如何定义这个返回类型是需要综合考虑的。 方法名 就是有名字，方便我们在调用时指定，只要是合法的标识符即可。 命名规则： 以小写字母开头，多个单词组成时，从第二个单词开始首字母大写。如：setName, toBinaryString, …. 方法名尽可能地有意义。 参数列表 parameter list 方法可以有0至多个参数。 如果有0个参数时，小括号也不能省略。 有多个参数时，每个参数之间使用逗号隔开。 参数的语法 同变量的语法，唯一不同在于，变量可以有初始值，而参数不支持默认值。 语法: 数据类型 参数名 所以，参数本身就是变量【也叫局部变量】，在方法体中，我们可以直接使用这些变量。 如： 1public static String toBinaryString(int i) { ... } //这个方法的参数i,叫 形参 在方法的定义中，这个参数我们叫 形参 , 此时，这个参数并没有实际的 值 只有发生了方法的调用，这个形参才会有值。 在调用方法时，我们需要传递目标方法的参数进去，这个被传递的参数叫 实参, 它是有值的 如：我们在代码中，要调用上面的 toBinaryString 方法，则 123int a = 19; //变量String result = Integer.toBinaryString(a); //发生了方法的调用[invoke]//此时，我们说 变量 a 就是 实参。 注: 实参名与形参名没有任何要求，但是，要求实参的类型要与形参的类型保持一致。 例: 请设计一个方法，用来计算某个整数的阶乘 123public double factor(int i) { //代码块 [算法的实现]} 请设计一个方法，用来判断某个整数是否是完美数 123public boolean isPerfectNumber(int i) { //代码块...} 请设计一个方法，用来返回一个指定高度的杨辉三角数据。 12345678910111213141516171819202122public int[][] yhTriangle(int high) { //代码块 int[][] result = new int[high][]; //算法 for(int i=0;i &lt; result.length; i++) { //初始化它的一维数组 result[i] = new int[i + 1]; //loop for(int j = 0; j &lt; result[i].length; j++) { //填充数据 //1. 任 一行的第1列和最后1列的值都是 1 if(j == 0 || i == j) { result[i][j] = 1; } else { //2. 其它列的值是上一行的同列和前一列之和 result[i][j] = result[i-1][j] + result[i-1][j-1]; } } } // 返回 return result;} 请设计一个方法，用来打印输出指定范围类的所有质数 123public void printPrime(int start, int end) { //代码块} 注: 写代码总是 变量先行 方法的重载[overload] 在同一个类中，拥有相同方法名，但参数列表不同的方法。 特点： 方法名相同 参数列表不同 参数个数不同 参数类型不同 在类型不同的基础上，参数顺序不同。 例: 12345....public int add(int a, int b) { return a + b; }public double add(int a, double b) { return a + b; }public double add(double a, int b) { return a + b; }public int add(byte a, byte b) { return a + b; } 当我们调用重载的方法时，JVM是如何选择的？ 首先，会采用精确类型匹配模式 去匹配目标方法，如果找到，就直接调用 其次，如果精确匹配找不到，则会尝试采用 就近向上类型匹配 模式 比如: 我们调用: 12345int a = 19;int b = 23;int result = xxx.add(a, b);byte c = 12;result = xxx.add(c, a); 思考: 我们何时要定义重载的方法呢？ 当这些在同一个类中的方法的业务逻辑是一样的时候。 注：除了普通方法可以做重载外，构造方法也是可以重载的 方法的调用时传值和传引用的区别 我们调用方法时，需要传递实参给目标方法的形参，在传 递参数时，JAVA有两种方式 传值 的方式 传引用的方式 这个是由目标方法的参数类型决定的，如果目标方法的参数是对象类型,则采用 传引用的方式， 如果目标方法的参数是基本类型 ，则采用传值的方式。 什么是引用呢？ 它是指向目标对象的地址，只有对象类型才有“引用”，因为只有对象类型的变量存放的是地址。 注：只要是对象类型，存放的就是地址, 所谓的找对象，本质上就是计算机的寻址过程 例： 1234567...public void swap(int a, int b) { int temp = a; a = b; b = temp;}//在此方法体内部，变量a和变量b 的确发生了交换，但是，并不会影响实参 以对象为参数的案例： 1234567public void swap(int[] a, int [] b) { // int[] temp = a; a = b; b = temp;}//此方法的形参是对象类型，实参所传递过来的也是地址/引用，但是，由在此方法体中，并没有通过地址去修改堆空间中的对象本身，所以，即使在这里变量a和变量b发生了交换，同样不会影响实参。","link":"/2019/09/19/javase/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"title":"java基础语法","text":"标识符 用来给JAVA编程元素命名的，它由字母、数字、_、$组成，并且不以数字开头的字符序列。 标识符尽量保持有意义，如：Hello, Cup, _abc, a5, … 数据类型【DataType】 有两大数据类型，一类是 基本类型， 另一类是 对象类型。 基本类型 [primitive type] 有 8 种，分别是： byte – 字节型，占 1 个字节, 数字范围： -128 ~ +127 short – 短整型，占2 个字节, 数字范围： -32768 ~ +32767 int – 整型，占4个字节, 数字范围： -2147483648 ~ +2147483647 long – 长整型，占8个字节, 数字范围： ….. double – 双精度浮点，占 8 个字节, 范围大小： +/- 10^308 float – 单精度浮点， 占 4个字节, 范围大小： +/- 10^38 char – 字符型，占 2个字节, 范围同 short 一样。它每个数字都对应的一个“字符”， 它是由字符编码来定义的，常用的编码有： ASCII 码，它采用单字节编码，它至多可以编 256 个字符。 GBK 码， 后来变成为 GB2312， 它是采用双字节编码，向上兼容ASCII 码。是国标。 UTF-8码，国际编码，它是动态字节编码，兼容大多数国家和地址的编码。 boolean – 布尔类型，占 1个字节 在计算机中，数据的存储以字节为单位，1个字节占8位二进制。 我们所熟知的G字节，相当于 1024 * 1024 * 1024 个字节。 1Gb = 1024 Mb 1Mb = 1024 Kb 1Kb = 1024 字节 每种类型的数字范围是如何算出来的？ 它是由二进制的位数决定的，而位数由 所占字节数决定的。 首先，理解一下 什么是二进制？ 它由 0 和 1 组成，最小是0，最大是1. 所以，1位二进制有2种变化， 2位二进制就有 2 * 2 种变化，依此类推，8位二进制就有 2^8 种变化，也就是 256 种状态。 二进制 十进制 0 000 0000 =&gt; 0 0 111 1111 =&gt; 2^7 - 1 = +127 . … ….. ….. 1 000 0000 =&gt; -128 1 111 1111 =&gt; -1 对象类型 是一种复合类型，它采用 class 来定义，它主要也有两大类： 由JRE自带的类型，如： java.lang.String, java.lang.System, java.util.Date, java.util.Scanner, … 由程序员自定义的类型， 比如：Hello, PkgDemo, ImpDemo, … 变量、字面量、常量变量 [variable] 指变化的量，它的值在程序运行过程中是可以改变的。 定义的语法： 数据类型 变量名 [= 初始值]; 注：JAVA是一种强类型编程语言，类型在编译期间就必须确定。 如： int i = 9; //定义了一个整型变量，变量名为 i, 它的初始值是 9【字面量】 再看： Date now = new Date(); //定义一个对象类型 注： 12对象类型的变量，简称 对象， 对象类型的变量必须通过 new 操作符来初始化。只有 String 类型是特殊的，它可以使用 字面量 来初始化，也可以使用 new 来初始化。基本类型的变量，简称 变量， 基本类型的变量可以直接使用 字面量 来初始化。 再来看更多的例子 123456789101112131415161718//定义基本类型byte b1 = 13; //okshort s1 = 15; //okint i1 = 3; //oklong x = 100L; //长整型以L或l 结尾。int i2 = 12L; //compile error, 有可能丢失精度char c = 'A'; //okString name = \"jack\"; //okboolean y = true; //okdouble d1 = 3.456; //okfloat f1 = 2.345F; //以 F 或 f结尾。//定义对象变量Date now = new Date();//定义对象变量Scanner scan = new Scanner(System.in); // 字面量 [literal] 就是字面本身的量，它的值是不可变的。 如：5, 18, 4.5, ‘我’, “我们”, “你”, true, false, …. 它的作用是用来给变量或常量赋值的。 常量[constant] 在程序运行过程中，不可以变化的量【也就是不可变的变量】 语法： final 数据类型 常量名 = 初始值; 注：常量在定义时必须被初始化。 常量名尽量使用大写字母 如： final int ROW = 10; //定义了一个整型常量 ROW, 它的值是 10 在代码修改或维护时，常量比字面量更有优势，所以，在程序中，除了给变量或常量赋值外，尽量不要直接使用字面量。 运算符 是用来运算的一些特殊符号，有： 赋值运算符 = 比较运算符 ==, &gt;, &lt;, !=, &gt;=, &lt;= 它的运算结果一定是 布尔值，也就是 true 或 false 算术运算符 +, -, *, /, %, +=, -=, *=, /= ++, 分为前++和后++， 前++是表达式的值增1，变量本身的值也增1。 后++ 是表达式的值不变，变量本身的值增1. –，分为前– 和 后– 如： int i = 9 ; int j = i++; // 此时：i = 10 , j = 9 int k = 13; int z = k++ + ++k; // k = 15, z = 28 算术运算符的规则 byte, short ,char, int 之间的算术和位运算，其结果一定是 int 除以上规则外，所有小范围数字类型 与大范围数字类型之间的运算，其结果一定是大范围数字类型。 ​ byte, short, int —&gt; long —&gt; float —&gt; double ​ char —-/ 如： byte b1 = 12; byte b2 = 13; byte b3 = b1 + b2; // compile error 逻辑运算符 &amp;&amp; - 逻辑与, 当两个操作数同时为真时，其结果为真，有一个为假，结果为假。 || - 逻辑或, 当两个操作数同时为假时，其结果为假，有一个为真，结果为真。 ! - 逻辑非， 真为假，假为真 注：&amp;&amp; 和 || 都是短路运算符，就是当操作数的一边能够确定整个表达式的结果时，另一边则直接不参与运算。 位运算符 &amp; - 按位与 | - 按位或 ^ - 按位异或 ~ - 按位取反 &gt;&gt; - 右移位， 正数，符号位补0， 负数，符号位补1 &gt;&gt;&gt; - 无符号右移位， 符号位总是补0 &lt;&lt; - 左移位 &amp;=, |=, ^=, ~=, &gt;&gt;= , &gt;&gt;&gt;=, &lt;&lt;= 首先，我们要理解二进制，因为，位运算都是二进制的方式进行的。 我们以一个整数为例 int i = 9; int j = 13; 它的二进制形式如下： 0 0000000 00000000 00000000 00001001 =&gt; 9 0 0000000 00000000 00000000 00001101 =&gt; 13 按位求与的结果是： 0 0000000 00000000 00000000 00001001 =&gt; 9 按位求或的结果是： 0 0000000 00000000 00000000 00001101 =&gt; 13 按位求异或的结果： 0 0000000 00000000 00000000 00000100 =&gt; 4 把变量i按位取反的结果是： 1 1111111 11111111 11111111 11110110 =&gt; -10 针对异或来说，存在如下的规律： 一个整数连续异或另一个整数2次，其值不变。 再来学习一下十六进制和八进制 十六进制由09和AF 组成，逢16进1，它的字面量形式是以 0x开头的。 八进制由0~7组成，逢8进1， 它的字面量形式是以 0 开头的。 在java中，整型即支持16进制的字面量也支持8进制的字面量，从JDK7开始，还支持二进制的字面量。 12345//如：int i = 19；//10进制的字面量，默认就是 10进制int j = 023; //8进制的字面量， 转换成10进制就是：2*8^1 + 3*8^0 = 16+3 = 19int k = 0x13; //16进制的字面量，转换成10进制就是：1*16^1 + 3*16^0 = 16 + 3 = 19int z = 0b10011; //2进制的字面量，转换成10进制就是：1*2^4+1*2^1+1*2^0 = 16+2+1 = 19 描述一下二、十六、10进制 的对应关系 1234567891011121314151617十进制 二进制 十六进制0 0 0x01 1 0x12 10 0x23 11 0x34 100 0x45 101 0x56 110 0x67 111 0x78 1000 0x89 1001 0x910 1010 0xA11 1011 0xB12 1100 0xC13 1101 0XD14 1110 0XE15 1111 0xF 位运算操作口决 清0取位要用与，某位置1可用或； 若要取反与交换，轻轻松松用异或。 三目运算符 ? : 相当一个 if语句，语法如下： expr1 ? expr2 : expr3; 当 expr1 成立时，执行并返回 expr2, 否则，执行并返回expr3 instanceof运算符 用来判断一个对象的类型。这个表达式的结果也是布尔值。 … 练习 设计一个程序，让用户从键盘输入任一整数，判断这个整数是否是偶数，是偶数，输出true， 不是的话，输出 false 表达式 【expression】 由变量、常量、字面量与运算符组成的合法语句。 所有的代码都是以表达式为基本单位的。 注释 有两种注释格式， 单行注释， 以 // 开头 多行注释， 以 /** 注释 */ 【文档注释，将来可以通过命令提取出来】 多行注释中，还有普通的，以 /* 注释 */ 文档注释必需放在如下位置才能被提取： package 的上面 class 的上面 方法的上面 属性的上面 在方法体中，不支持文档注释。","link":"/2019/09/19/javase/%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/"},{"title":"集合-Map","text":"回顾一下Collection分支 List, 有序、可重复 ArrayList LinkedList Vector Stack – 设计有缺陷，不建议使用 Set， 无序、不可重复的 HashSet – 组合了一个HashMap来实现的 SortedSet TreeSet – 组合了一个 TreeMap 来实现的 Queue，FIFO（先进先出） PriorityQueue Deque – Double End Queue Map与Collection不同，Map存储的是键-&gt;值 对，也就是 Key -&gt; Value, 本质上在Map内部，这个key和value会被封装成 Map.Entry 对象， 这个对象中拥有key和value 两个属性。 Map的特点： key是无序的、不可重复的 key可以为null, 注：对value没有任何要求。 Map的常用操作 put(K key, Value v) 把一对键值对存放当前的Map中 get(K key) -&gt; Value 通过key来获取Value containsKey(K key) 判断当前的MAP中是否包含指定的key containsValue(V value) 判断当前的MAP中是否包含指定的Value 三个方法可以把MAP转换成Set或Collection values() -&gt; Collection 把Map的所有值取出来，形成一个Collection并返回 keySet() -&gt; Set 把MAP的所有KEY取出来，形成一个SET并返回，不含VALUE entrySet() -&gt; Set&lt;Entry&lt;K, V&gt;&gt; 把MAP的所有KEY和VALUE都取来，并封装成Entry对象，把Entry对象存放到Set中，并返回 Map的实现类 - HashMap 此类采用哈希算法来实现Map， 它的原理如下： 首先，当把一个对象put到HashMap中时，容器会调用此对象的hashcode方法获取对象的哈希码值，根据此哈希码值来计算出此对象应该存放的位置“桶”。 其次，当再把一个对象put到此HashMap中时，容器同样会调用此对象的hashcode方法获取对象的哈希码值，再根据此哈希码值来计算出此对象应该存放的位置“桶”。如果此时，这个位置”桶”被前面的对象给占用了，那么容器会调用此对象的equals()方法来判断此对象与占桶对象是否是“相等”，如果equals方法返回true，则相等，那么后面会覆盖前面。如果equals方法返回false, 则容器会把撞桶的对象采用平衡二叉树来存储，并且是用红黑树算法来决定它的位置。 最后，每个对象 的加入都重复上面的第2步。 有关二叉树的知识 普通二叉树，就是把数据以左孩子和右孩子 的方式进行存储，不是采用线性结构，如下： 1234567//二叉树的数据节点封装结构class Node { Node left; // 指向左孩子的指针 Node right; //指向右孩子的指针 Object data; //数据 //....} 注：普通二叉树使用价值不高 排序二叉树【Search Binary Tree】，是指左孩子节点值比它的根节点值要小，右孩子节点值比它的根节点值要大。每一个子树也是同样的规则 注：排序二叉有 前序、中序、后序三种遍历方式。 平衡二叉树【Balanced Binary Tree】，首先它是排序二叉树，再满足如下要求 左子树的高度与右子树的高度差，其绝对值小于或等于1 SortedMap [接口] 可排序的Map, 它是Map的子接口，提供了自动排序的功能。 它要求存放在此容器中的key是能够比较的。API 中提供了两种比较的接口 java.lang.Comparable 接口 【可比较器的】 它里面有一个 compareTo方法。 java.util.Comparator 接口 【比较器】 它里面有一个 compare 方法 第一： 如果我们不传递比较器到SortedMap中，则要求你加入到此容器的中对象必需要实现 Comparable 接口，这样一来，当你开始添加第2个对象时，容器会把你传入的对象强制类型转换成 Comparable 接口，并且调用对象的compareTo方法，从而决定他们之间的大小，也就决定了存放的位置。 第二：如果我们传递了一个比较器对象到此容器中，此种情况下，就不要求被添加的对象去实现Comparable 接口，而是通过这个比较器去比较。它的原理如下： ​ - 从添加第2个对象开始，调用比较器的compare 方法，并把前面已经存在的1个对象和刚加入的对象做参数传递给这个compare 方法，由这个方法决定两个对象的大小，如果返回0，表示相同，后面的会把前面的覆盖掉，如果返回-1,表示后加入的比前面的小。如果返回1，表示后加入的比前面的大。 实现类：TreeMap 底层采用平衡二叉树来实现。 常用方法： public TreeMap() 要求被添加对象要实现 Comparable 接口 注：在JDK, 以下几种常用类型都是实现了 Comparable 接口的， Integer, Long String Date .. 所以，我们使用Map时，Key的类型尽量使用 Integer, Long, String, 如果你的Key是一个自定义类型，那最好实现 Comparable 接口。 public TreeMap(Comparator c) 传入比较器， 这种方式更加灵活，对Key没有实现 Comparable 接口的要求。 public TreeMap(Map m); … 再来看看 TreeSet 此实现类实现了 SortedSet 接口，此类本质上是组合了 TreeMap对象。利用了 TreeMap的Key的位置来存储元素。所以，对于TreeSet而言，它同样有如下构造 public TreeSet() 要求被添加了对象实现 Comparable 接口 public TreeSet(Comparator c) 由于传入了比较器，所以，不要求 元素实现 Comparable 接口。 JCF小结1234567891011121314151617181920212223java.lang.Iterable \\- java.util.Collection \\- java.util.List \\- ArrayList 数组实现的 \\- LinkedList 双向链表实现的 \\- Vector \\- java.util.Set \\- HashSet 哈希算法+红黑树， 组合了 HashMap \\- java.util.SortedSet \\- TreeSet 平衡二叉树，组合了 TreeMap \\- java.util.Queue \\- PriorityQueue 优先队列 \\- java.util.Deque 双端队列 \\- ArrayDeque 数组 java.util.Map \\- HashMap 哈希算法 \\- java.util.SortedMap \\- TreeMap 平衡二叉树实现 //两个做比较的接口java.lang.Comparable&lt;T&gt;java.util.Comparator&lt;T&gt; 泛型 Generic 泛型就是类型参数化 泛型有如下特点： 泛型是编译时的概念，在运行时并不存在泛型。 泛型不存在多态【因为它只是编译期的概念】 如： 1234567List a = new ArrayList(); //okObject b = new Student(); //okList&lt;Object&gt; ab = new ArrayList&lt;Student&gt;(); //compile errorList&lt;Student&gt; ab = new ArrayList&lt;Student&gt;(); //ok//或List&lt;Student&gt; ab = new ArrayList&lt;&gt;(); //ok 泛型字母 就是一个泛型的符号代替，一般使用单个字母，如：T, K, V, E, S, … 泛型类的定义语法： 1234567public class 类型&lt;T&gt; { //属性 //方法 在类型中定义了泛型字母，在属性和方法中就可以使用这个泛型字母 T} 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SimpleStack&lt;T&gt; { //采用组合模式 private LinkedList&lt;T&gt; container; public SimpleStack() { //初始化这个容器 this.container = new LinkedList&lt;T&gt;(); } public void push(T element) { //把元素放在第一个位置 this.container.push(element); //等价于调用 addFirst() } public T pop() { //永远取出列表中的第1个元素 return this.container.pop(); //等 价于调用 removeFirst() } public boolean isEmpty() { return this.container.isEmpty(); } public int size() { return this.container.size(); } //只返回本栈的栈顶元素，但是此元素并不从栈中移除 public T peek() { return this.container.peek(); }}//使用：public static void main(String[] args) { // SimpleStack&lt;Integer&gt; ss1 = new SimpleStack&lt;&gt;(); ss1.push(12); //ok // SimpleStack&lt;String&gt; ss2 = new SimpleStack&lt;&gt;(); ss2.push(\"jack\"); //ok} 泛型方法的定义 此处所指是指 在类的层面上，没有定义泛型字母，而在方法中需要使用泛型。 泛型方法的定义一般都在 工具类，因为工具类的方法都是静态的。 语法： 修饰符 返回类型 方法名(T p, … )throws 异常列表 { … } 如： 123456789public class 类名 { //属性 //方法 public void ma() { .... } //泛型方法: 在返回类型和修饰符之间，要单独定义泛型字母，这样一来，在方法体中，就可以使用这个泛型字母。 public &lt;T&gt; void mb(T p) { ... }} 泛型通配符 wildcards ? 通配任意类型 1234567891011121314151617List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); //okintList.add(100); //okList&lt;String&gt; strList = new ArrayList&lt;&gt;(); //okstrList.add(\"jack\"); //okList&lt;?&gt; hehe = new ArrayList&lt;String&gt;(); //okhehe.add(null); //okhehe.add(\"jack\"); //error//public void print(List&lt;?&gt; container) { // for(Object o : container) { System.out.println(o); }} 进一步对通配符进行限定，可以限定类型上限，也可以限定类型下限 &lt;? extends 类型&gt; 指定上限 &lt;? super 类型&gt; 指定下限 集合的工具类 Collections 方法详见API文档 addAll() sort() ncopies() shuffle() …. 枚举 [enum] 同样是一种类型，利用 enum 关键字来定义, 编译完成后，也是字节码文件。 枚举是一种类型安全的常量类 语法： 1234567public enum 枚举名 { //属性 //1.普通属性，同 class 一样，使用不多 //2.常量属性，也就是枚举本身的公开静态常量, 每一个枚举常量，都是枚举本身的一个实例。 //方法} 如： 12345678910public enum Season { //普通属性 private String name; //常量属性 SPRING, SUMMER, AUTUMN, WINTER;} 注：拥有固定值的信息适合定义成枚举，如：四季、星期、月份、交通信号灯、扑克牌花色、扑克牌点数、… 枚举的特点 它的构造方法一定是私有的。 枚举中也可以定义抽象方法，每一个枚举常量都必需要实现这个抽象方法。 我们定义的枚举，都自动继承于 java.lang.Enum 为什么 说枚举常量是类型安全的常量呢？ 因为枚举的常量，都是指向本类的实例，不是其它的类型。 因为枚举的构造方法默认就是私有的，而且只能是私有的。 123456789101112131415161718192021222324252627282930313233public class Constant { public static final Constant SPRING = new Constant(); public static final Constant SUMMER = new Constant(); public static final Constant AUTUMN = new Constant(); public static final Constant WINTER = new Constant(); private Constant() {}}//以上的类就是枚举的本质，改成使用 enum 来定义如下：public enum Season { SPRING, SUMMER, AUTUMN, WINTER;} //public class UseXX { //参数season取出常量类 Constant的四个常量之一 public static String convert(Constant season) { if(season == Constant.SPRING) { return \"春天\"; } else if(season == Constant.SUMMER) { return \"\"; } .... } public static void main(String[] args) { // String s = convert(Constant.SPRING); }} 作业 定义一个扑克牌花色 的枚举, 包含 黑、红、梅、方 四个枚举常量 定义一个扑克牌点数的枚举，包含 1，2，3，4，5，。。。，J,Q,K 13个枚举常量 定义一个卡片类[Card], 内置2个属性， 花色和点数， 提供构造方法、getter/setter、 toString, hashcode,equals方法 定义一个扑克牌类[Poker], 提供如下属性： private List cards; private boolean hasKing; //是否包含大小王，如果此属性为真 ，则cards中要含大小王。如果为假，则cards中不含大小王。 再定义如下方法 空参构造， 相当于hasKing属性为假，不含大小王来填充 cards 带boolean 类型构造，由用户决定是否要含大小王，如果传入真，则要包含大小王来填充 cards public List newPoker() { } //获取一封新的扑克牌 public void shuffle(List cards) {} //洗牌 public void play(List cards, int player, int cardsForEach) {} //发牌，其中，cards代表扑克牌，player代表玩家数量， cardsForEach 代表每个玩家发多少张牌。 此方法要求把每个玩家的牌打印出来。","link":"/2019/09/19/javase/%E9%9B%86%E5%90%882%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE/"},{"title":"面向对象","text":"是一种编程的方法论，也是一种软件构建的指导思想。 先整体后局部，也就是 TOP - DOWN 的思维，与之对应的是”面向过程”编程思想。 面向过程比较注重的是 方法的构建，侧重点就是 数据结构+算法。 而面向对象是不以方法做为构建的基本单位，在方法之上，创造了””新的一层”,这一层可以理解为 “抽象类”,在这个类中，封装了方法，在方法中，同样需要 数据结构 + 算法。这样一来，做为的软件的构建者，我们不是直接与“方法”来打交道，而是基于中间层的“类/对象” 来构建软件 所以，面向对象的首要任务就是如何去“找到”符合我们业务需求的这些“类/对象“，而不是直接去想方法和实现。基于这点，面向对象思想有了三大基本特征： 封装 继承 多态 注：面向对象编程思想不是java语言特有的，它是超脱于编程语言之外的，任何的编程只要满足以上三个基本特征，它就可以是面向对象的编程语言。 当我们接到一个软件业务需求的时候，以面向对象的思想我们该如何去分析？ 从宏观上找到这个需求当中需要参与的“对象”【不是找具体的数据结构和算法】 我们需要进一步分析这些“对象”，对它们进行“归类” 【抽象的过程】 对这些对象进行“业务功能”的赋予 对这些”业务功能“进行细节上的实现，此时，就需要考虑数据结构 + 算法。 以上的分析就是TOP - DOWN 的思维，也就是面向对象的方法论。 – 我们在开发代码时，第一步实际上是大脑的思维活动，而真正写出代码已经到了第2步。 在客观世界中，我们先有“对象”，然后再“归类” 在代码世界中，我们要先开发出类型，然后才能实例化出对象。 这与我们大脑的思维活动是一致的，所以，面向对象编程是很符合大脑的思维习惯的。 – 在JAVA中如何定义一个类型？ 123public class 类型 { } 我们要如何去给这个类型添加“业务功能”呢？ 从2个维度去描述它， 这个类型拥有什么？ 就叫 属性[field], 一般数据结构由属性来封装 这个类型能干什么？ 就叫 方法【method】， 一般算法由方法封装。 下面再来看看 属性 的定义语法： 1修饰符 数据类型 属性名 [= 初始值]; 这个语法与变量几乎一致，所以，属性也是一种变量，叫 实例变量 方法的定义语法： 123修饰符 返回类型 方法名(参数列表) [申明所抛出的异常类型列表] { //方法体} 把属性和方法装入到“类型”中后， 再来看看类的定义： 12345678910public class 类型 { //属性的定义 修饰符 数据类型 属性名 [= 初始值]; ... //方法的定义 修饰符 返回类型 方法名(参数列表) [申明所抛出的异常类型列表] { //方法体 }} 注：类型中，可以定义0至多个属性和0至多个方法. 开发类的难点 不知道该给这个类赋予什么样的属性 不知道该给这个类赋予什么样的方法 开发类的过程中的易点 方法的实现。 数据结构的选择 属性的默认值 当我们创建对象时，属性会有默认值 ，其中 对象类型 的属性默认值是 null byte,short,int的默认值是 0 long 的默认值是 0L char 的默认值是 \\u0000 double,float的默认值是 0.0[保留1位小数时] boolean 的默认值是 false 对象创建的过程 new 关键字：它是一个运算符，它的作用就是用来申请堆空间[heap area]【堆空间是JVM的一块内存空间】 申请堆空间 【是根据属性的大小来定的，基本类型的大小是固定的，对象类型存放的总是地址，地址总是占 4个字节】 给属性赋默认值 调用构造方法，给属性赋值。 所以，普通属性是每个对象独享的，也就是说，同一个类的不同实例/对象拥有此类的所有属性的一个副本，每个对象的属性值可以是不一样的。你修改某个对象的普通属性值，并不会影响其它对象的属性值。 构造方法 是一种特殊的方法，它的作用是用来给属性赋值的。当我们创建对象时，JVM会调用构造方法。 构造方法的特点： 方法名与类名 一样 构造方法没有返回值。 如果你在代码中，没有显示地定义类的构造方法，则JVM会自动为此类生成一个空参构造方法。如果你有定义构造方法，则JVM 不提供空参构造 构造方法也可以重载。 我们通过new 运算符来调用构造方法，根据调用者的参数个数和类型去与目标构造方法匹配，如果匹配成功，则调用目标构造方法，如果没有对应的方法，则报编译错误。 对象和类的关系 类是对象的抽象化概念，它是我们抽象出来的一个概念。 对象是类的具体化/实例化 对象和引用的关系 对象是存放在堆空间中数据的载体 引用是存放在栈空间中指向堆空间对象的地址，也叫引用。 我们要通过引用去操作对象。【引用也叫对象的句柄】 如果一个对象没有了引用指向它，则JVM的GC线程就会回收这个对象，把堆空间给释放出来。 12一个引用在某一时刻只能指向一个对象。而一个对象可以被多个引用指向 this 关键字 表示当前对象，它是指向当前对象的一个引用。当方法的形参名与属性名同名时，可以使用这个关键字来加以区分。 用来调用其它的构造方法, 要求：必需要写在构造方法的第一行代码。 封装 该隐藏的隐藏，该公开的公开！ 简单遵守以下原则： 属性应该隐藏，因为属性一般是封装了数据的，而数据往往是敏感的，所以，应该隐藏。 业务方法应该公开，因为业务方法是对外的。 属性私有化后，外界如何去读取以及修改属性的值？ 我们要提供属性的读、写的公开方法，并在这些方法有选择地进行判断。 针对业务方法的封装也有两种策略 把类的属性、构造、getter/setter 方法和业务方法一起封装在同一个类中。 把类的属性、构造、getter/setter 方法单独封装起来，然后，把业务方法另外封装成一个类。 案例设计一个类，封装银行帐户类，可以提供存钱、取钱、转帐等业务。 分析： 这个类拥有什么？ 余额，帐号，拥有者 这个类能干什么？ 存钱、取钱、转帐、… 策略一 123456789101112131415161718192021public class Account { //属性 private String accountNo; private double balance; private String owner; //构造方法 ... // getter/setter 方法 ... // 业务功能方法 public int deposit(double money) { //... } // public int withdraw(double money) { } public int transfer(Account target, double money){ }} 策略二 [使用更多] 12345678910111213141516171819202122232425public class Account { //属性 private String accountNo; private double balance; private String owner; //构造方法 ... // getter/setter 方法 ... //不写业务方法}//把业务方法单独封装public class AccountService { // 业务功能方法 public int deposit(Account a, double money) { //... } // public int withdraw(Account a, double money) { } public int transfer(Account from, Account target, double money){ }} 此策略的扩展性较好，它采用各司其职的思念，其中，封装了属性和get/set方法的类，叫实体类，它的对象就是数据的载体，封装了业务功能方法的类，叫业务类，它的对象是方法的载体。","link":"/2019/09/19/javase/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"docker入门","text":"Docker学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。（2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123{&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]} 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t='jdk1.8' . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1{\"insecure-registries\":[\"192.168.184.141:5000\"]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8","link":"/2019/09/19/docker/Docker/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"javaSE","slug":"javaSE","link":"/tags/javaSE/"},{"name":"应用容器引擎","slug":"应用容器引擎","link":"/tags/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"java基础","slug":"Java/java基础","link":"/categories/Java/java%E5%9F%BA%E7%A1%80/"},{"name":"docker","slug":"docker","link":"/categories/docker/"}]}